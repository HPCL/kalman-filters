#include "../../linear_algebra.h"

void add_matrix(TYPE* mat_a, int rows, int cols, TYPE* mat_b, TYPE* mat_c)  {

/*@ begin PerfTuning (

 def build {
   arg build_command = 'icc';
   #arg libs = '-lrt';  # Only needed on linux
 } 

 def performance_counter {
   arg repetitions = 50;
 }

 def performance_params {  
  param U_I[] = range(1,6);
  param U_J[] = range(1,6);

  param RT1_I[] = [1,2,6];
  param RT1_J[] = [1,2,6];

  param VEC[] = [False,True];

  param CFLAGS[] = ['-O1', '-O2', '-O3'];
  constraint unroll_limit = ((U_I == 1) or (U_J == 1));

  constraint reg_capacity_1 = (RT1_I*RT1_J <= 150);
 }
 
 def input_params {
  let N = [6];
  param rows[] = N;
  param cols[] = N;
 }
 
 def input_vars {
   decl dynamic double mat_a[rows*cols] = random;
   decl dynamic double mat_b[rows*cols] = random;
   decl dynamic double mat_c[rows*cols] = 0;
 }
 
 def search {
   arg algorithm = 'Exhaustive';
 }

) @*/
/**-- (Generated by Orio) 
Best performance cost: 
  [1.341e-06, 3.44e-07, 2.03e-07, 1.97e-07, 1.99e-07, 1.95e-07, 1.99e-07, 1.96e-07, 1.96e-07, 1.95e-07, 1.96e-07, 1.96e-07, 1.97e-07, 1.97e-07, 1.95e-07, 1.96e-07, 1.97e-07, 1.95e-07, 1.96e-07, 1.95e-07, 1.96e-07, 1.96e-07, 1.96e-07, 1.97e-07, 1.96e-07, 1.96e-07, 1.95e-07, 1.95e-07, 1.96e-07, 1.95e-07, 1.96e-07, 1.96e-07, 1.98e-07, 1.96e-07, 1.96e-07, 1.97e-07, 1.97e-07, 1.97e-07, 1.96e-07, 1.96e-07, 1.96e-07, 1.94e-07, 1.94e-07, 1.96e-07, 1.95e-07, 1.95e-07, 1.96e-07, 1.95e-07, 1.96e-07, 1.95e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O2 
  RT1_I = 6 
  RT1_J = 6 
  U_I = 5 
  U_J = 1 
  VEC = True 
--**/


int i, j;
int it, jt;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always']),
    regtile = (['i','j'],[RT1_I,RT1_J])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  for (it=0; it<=rows-6; it=it+6) {
    register int cbv_1;
    cbv_1=cols-6;
#pragma ivdep
#pragma vector always
    for (jt=0; jt<=cbv_1; jt=jt+6) {
      mat_c[cols*it+jt]=mat_a[cols*it+jt]+mat_b[cols*it+jt];
      mat_c[cols*it+(jt+1)]=mat_a[cols*it+(jt+1)]+mat_b[cols*it+(jt+1)];
      mat_c[cols*it+(jt+2)]=mat_a[cols*it+(jt+2)]+mat_b[cols*it+(jt+2)];
      mat_c[cols*it+(jt+3)]=mat_a[cols*it+(jt+3)]+mat_b[cols*it+(jt+3)];
      mat_c[cols*it+(jt+4)]=mat_a[cols*it+(jt+4)]+mat_b[cols*it+(jt+4)];
      mat_c[cols*it+(jt+5)]=mat_a[cols*it+(jt+5)]+mat_b[cols*it+(jt+5)];
      mat_c[cols*(it+1)+jt]=mat_a[cols*(it+1)+jt]+mat_b[cols*(it+1)+jt];
      mat_c[cols*(it+1)+(jt+1)]=mat_a[cols*(it+1)+(jt+1)]+mat_b[cols*(it+1)+(jt+1)];
      mat_c[cols*(it+1)+(jt+2)]=mat_a[cols*(it+1)+(jt+2)]+mat_b[cols*(it+1)+(jt+2)];
      mat_c[cols*(it+1)+(jt+3)]=mat_a[cols*(it+1)+(jt+3)]+mat_b[cols*(it+1)+(jt+3)];
      mat_c[cols*(it+1)+(jt+4)]=mat_a[cols*(it+1)+(jt+4)]+mat_b[cols*(it+1)+(jt+4)];
      mat_c[cols*(it+1)+(jt+5)]=mat_a[cols*(it+1)+(jt+5)]+mat_b[cols*(it+1)+(jt+5)];
      mat_c[cols*(it+2)+jt]=mat_a[cols*(it+2)+jt]+mat_b[cols*(it+2)+jt];
      mat_c[cols*(it+2)+(jt+1)]=mat_a[cols*(it+2)+(jt+1)]+mat_b[cols*(it+2)+(jt+1)];
      mat_c[cols*(it+2)+(jt+2)]=mat_a[cols*(it+2)+(jt+2)]+mat_b[cols*(it+2)+(jt+2)];
      mat_c[cols*(it+2)+(jt+3)]=mat_a[cols*(it+2)+(jt+3)]+mat_b[cols*(it+2)+(jt+3)];
      mat_c[cols*(it+2)+(jt+4)]=mat_a[cols*(it+2)+(jt+4)]+mat_b[cols*(it+2)+(jt+4)];
      mat_c[cols*(it+2)+(jt+5)]=mat_a[cols*(it+2)+(jt+5)]+mat_b[cols*(it+2)+(jt+5)];
      mat_c[cols*(it+3)+jt]=mat_a[cols*(it+3)+jt]+mat_b[cols*(it+3)+jt];
      mat_c[cols*(it+3)+(jt+1)]=mat_a[cols*(it+3)+(jt+1)]+mat_b[cols*(it+3)+(jt+1)];
      mat_c[cols*(it+3)+(jt+2)]=mat_a[cols*(it+3)+(jt+2)]+mat_b[cols*(it+3)+(jt+2)];
      mat_c[cols*(it+3)+(jt+3)]=mat_a[cols*(it+3)+(jt+3)]+mat_b[cols*(it+3)+(jt+3)];
      mat_c[cols*(it+3)+(jt+4)]=mat_a[cols*(it+3)+(jt+4)]+mat_b[cols*(it+3)+(jt+4)];
      mat_c[cols*(it+3)+(jt+5)]=mat_a[cols*(it+3)+(jt+5)]+mat_b[cols*(it+3)+(jt+5)];
      mat_c[cols*(it+4)+jt]=mat_a[cols*(it+4)+jt]+mat_b[cols*(it+4)+jt];
      mat_c[cols*(it+4)+(jt+1)]=mat_a[cols*(it+4)+(jt+1)]+mat_b[cols*(it+4)+(jt+1)];
      mat_c[cols*(it+4)+(jt+2)]=mat_a[cols*(it+4)+(jt+2)]+mat_b[cols*(it+4)+(jt+2)];
      mat_c[cols*(it+4)+(jt+3)]=mat_a[cols*(it+4)+(jt+3)]+mat_b[cols*(it+4)+(jt+3)];
      mat_c[cols*(it+4)+(jt+4)]=mat_a[cols*(it+4)+(jt+4)]+mat_b[cols*(it+4)+(jt+4)];
      mat_c[cols*(it+4)+(jt+5)]=mat_a[cols*(it+4)+(jt+5)]+mat_b[cols*(it+4)+(jt+5)];
      mat_c[cols*(it+5)+jt]=mat_a[cols*(it+5)+jt]+mat_b[cols*(it+5)+jt];
      mat_c[cols*(it+5)+(jt+1)]=mat_a[cols*(it+5)+(jt+1)]+mat_b[cols*(it+5)+(jt+1)];
      mat_c[cols*(it+5)+(jt+2)]=mat_a[cols*(it+5)+(jt+2)]+mat_b[cols*(it+5)+(jt+2)];
      mat_c[cols*(it+5)+(jt+3)]=mat_a[cols*(it+5)+(jt+3)]+mat_b[cols*(it+5)+(jt+3)];
      mat_c[cols*(it+5)+(jt+4)]=mat_a[cols*(it+5)+(jt+4)]+mat_b[cols*(it+5)+(jt+4)];
      mat_c[cols*(it+5)+(jt+5)]=mat_a[cols*(it+5)+(jt+5)]+mat_b[cols*(it+5)+(jt+5)];
    }
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=jt; j<=cbv_2; j=j+1) {
      mat_c[cols*it+j]=mat_a[cols*it+j]+mat_b[cols*it+j];
      mat_c[cols*(it+1)+j]=mat_a[cols*(it+1)+j]+mat_b[cols*(it+1)+j];
      mat_c[cols*(it+2)+j]=mat_a[cols*(it+2)+j]+mat_b[cols*(it+2)+j];
      mat_c[cols*(it+3)+j]=mat_a[cols*(it+3)+j]+mat_b[cols*(it+3)+j];
      mat_c[cols*(it+4)+j]=mat_a[cols*(it+4)+j]+mat_b[cols*(it+4)+j];
      mat_c[cols*(it+5)+j]=mat_a[cols*(it+5)+j]+mat_b[cols*(it+5)+j];
    }
  }
  {
    int i;
    for (i=it; i<=rows-5; i=i+5) {
      register int cbv_3;
      cbv_3=cols-6;
#pragma ivdep
#pragma vector always
      for (jt=0; jt<=cbv_3; jt=jt+6) {
        mat_c[cols*i+jt]=mat_a[cols*i+jt]+mat_b[cols*i+jt];
        mat_c[cols*i+jt+1]=mat_a[cols*i+jt+1]+mat_b[cols*i+jt+1];
        mat_c[cols*i+jt+2]=mat_a[cols*i+jt+2]+mat_b[cols*i+jt+2];
        mat_c[cols*i+jt+3]=mat_a[cols*i+jt+3]+mat_b[cols*i+jt+3];
        mat_c[cols*i+jt+4]=mat_a[cols*i+jt+4]+mat_b[cols*i+jt+4];
        mat_c[cols*i+jt+5]=mat_a[cols*i+jt+5]+mat_b[cols*i+jt+5];
        mat_c[cols*(i+1)+jt]=mat_a[cols*(i+1)+jt]+mat_b[cols*(i+1)+jt];
        mat_c[cols*(i+1)+jt+1]=mat_a[cols*(i+1)+jt+1]+mat_b[cols*(i+1)+jt+1];
        mat_c[cols*(i+1)+jt+2]=mat_a[cols*(i+1)+jt+2]+mat_b[cols*(i+1)+jt+2];
        mat_c[cols*(i+1)+jt+3]=mat_a[cols*(i+1)+jt+3]+mat_b[cols*(i+1)+jt+3];
        mat_c[cols*(i+1)+jt+4]=mat_a[cols*(i+1)+jt+4]+mat_b[cols*(i+1)+jt+4];
        mat_c[cols*(i+1)+jt+5]=mat_a[cols*(i+1)+jt+5]+mat_b[cols*(i+1)+jt+5];
        mat_c[cols*(i+2)+jt]=mat_a[cols*(i+2)+jt]+mat_b[cols*(i+2)+jt];
        mat_c[cols*(i+2)+jt+1]=mat_a[cols*(i+2)+jt+1]+mat_b[cols*(i+2)+jt+1];
        mat_c[cols*(i+2)+jt+2]=mat_a[cols*(i+2)+jt+2]+mat_b[cols*(i+2)+jt+2];
        mat_c[cols*(i+2)+jt+3]=mat_a[cols*(i+2)+jt+3]+mat_b[cols*(i+2)+jt+3];
        mat_c[cols*(i+2)+jt+4]=mat_a[cols*(i+2)+jt+4]+mat_b[cols*(i+2)+jt+4];
        mat_c[cols*(i+2)+jt+5]=mat_a[cols*(i+2)+jt+5]+mat_b[cols*(i+2)+jt+5];
        mat_c[cols*(i+3)+jt]=mat_a[cols*(i+3)+jt]+mat_b[cols*(i+3)+jt];
        mat_c[cols*(i+3)+jt+1]=mat_a[cols*(i+3)+jt+1]+mat_b[cols*(i+3)+jt+1];
        mat_c[cols*(i+3)+jt+2]=mat_a[cols*(i+3)+jt+2]+mat_b[cols*(i+3)+jt+2];
        mat_c[cols*(i+3)+jt+3]=mat_a[cols*(i+3)+jt+3]+mat_b[cols*(i+3)+jt+3];
        mat_c[cols*(i+3)+jt+4]=mat_a[cols*(i+3)+jt+4]+mat_b[cols*(i+3)+jt+4];
        mat_c[cols*(i+3)+jt+5]=mat_a[cols*(i+3)+jt+5]+mat_b[cols*(i+3)+jt+5];
        mat_c[cols*(i+4)+jt]=mat_a[cols*(i+4)+jt]+mat_b[cols*(i+4)+jt];
        mat_c[cols*(i+4)+jt+1]=mat_a[cols*(i+4)+jt+1]+mat_b[cols*(i+4)+jt+1];
        mat_c[cols*(i+4)+jt+2]=mat_a[cols*(i+4)+jt+2]+mat_b[cols*(i+4)+jt+2];
        mat_c[cols*(i+4)+jt+3]=mat_a[cols*(i+4)+jt+3]+mat_b[cols*(i+4)+jt+3];
        mat_c[cols*(i+4)+jt+4]=mat_a[cols*(i+4)+jt+4]+mat_b[cols*(i+4)+jt+4];
        mat_c[cols*(i+4)+jt+5]=mat_a[cols*(i+4)+jt+5]+mat_b[cols*(i+4)+jt+5];
      }
      register int cbv_4;
      cbv_4=cols-1;
#pragma ivdep
#pragma vector always
      for (j=jt; j<=cbv_4; j=j+1) {
        mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
        mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
        mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
        mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
        mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      }
    }
    for (i=rows-((rows-(it))%5); i<=rows-1; i=i+1) {
      register int cbv_5;
      cbv_5=cols-6;
#pragma ivdep
#pragma vector always
      for (jt=0; jt<=cbv_5; jt=jt+6) {
        mat_c[cols*i+jt]=mat_a[cols*i+jt]+mat_b[cols*i+jt];
        mat_c[cols*i+(jt+1)]=mat_a[cols*i+(jt+1)]+mat_b[cols*i+(jt+1)];
        mat_c[cols*i+(jt+2)]=mat_a[cols*i+(jt+2)]+mat_b[cols*i+(jt+2)];
        mat_c[cols*i+(jt+3)]=mat_a[cols*i+(jt+3)]+mat_b[cols*i+(jt+3)];
        mat_c[cols*i+(jt+4)]=mat_a[cols*i+(jt+4)]+mat_b[cols*i+(jt+4)];
        mat_c[cols*i+(jt+5)]=mat_a[cols*i+(jt+5)]+mat_b[cols*i+(jt+5)];
      }
      register int cbv_6;
      cbv_6=cols-1;
#pragma ivdep
#pragma vector always
      for (j=jt; j<=cbv_6; j=j+1) {
        mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      }
    }
  }
}
/*@ end @*/
/*@ end @*/

}