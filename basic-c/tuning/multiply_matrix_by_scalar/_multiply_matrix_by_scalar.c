#include "../../linear_algebra.h"


void multiply_matrix_by_scalar(TYPE* mat_a, int rows, int cols, TYPE scalar, TYPE* mat_c) {

  /*@ begin PerfTuning (

    def build {
      arg build_command = 'gcc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 5;
    }

    def performance_params {  
      param U_I[] = range(1,31);
      param U_J[] = range(1,31);

      param VEC[] = [False,True];

      param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];
      constraint unroll_limit = ((U_I == 1) or (U_J == 1));

    }

    def input_params {
      let N = [10, 20];
      param rows[] = N;
      param cols[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[rows*cols] = random;
      decl dynamic double mat_b[rows*cols] = random;
      decl dynamic double mat_c[rows*cols] = 0;
      decl double scalar = random;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) @*/
  if ((rows<=10) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.431e-06, 6.4e-07, 5.48e-07, 5.46e-07, 5.43e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=10) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.381e-06, 9.9e-07, 9.05e-07, 8.99e-07, 8.95e-07] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=20) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.939e-06, 9.96e-07, 9.27e-07, 9.23e-07, 9.21e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=20) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.83e-06, 1.721e-06, 1.607e-06, 1.597e-06, 1.601e-06] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 20 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-20; i=i+20) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      row=cols*(i+15);
      row=cols*(i+16);
      row=cols*(i+17);
      row=cols*(i+18);
      row=cols*(i+19);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%20); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
}
/*@ end @*/

  
}
