#include "../../linear_algebra.h"


void multiply_matrix_by_scalar(KALMAN_TYPE* mat_a, int rows, int cols, KALMAN_TYPE scalar, KALMAN_TYPE* mat_c) {
 
#ifdef USE_CALI
CALI_CXX_MARK_FUNCTION;
#endif
  /*@ begin PerfTuning (

    def build {
      arg build_command = 'icc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 50;
    }

    def performance_params {  
      param U_I[] = range(1,6);
      param U_J[] = range(1,6);

      param RT1_I[] = [1,2,6];
      param RT1_J[] = [1,2,6];

      param VEC[] = [False,True];

      param CFLAGS[] = ['-O1', '-O2', '-O3'];
      constraint unroll_limit = ((U_I == 1) or (U_J == 1));
      constraint reg_capacity_1 = (RT1_I*RT1_J <= 150);

    }

    def input_params {
      let N = [6];
      param rows[] = N;
      param cols[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[rows*cols] = random;
      decl dynamic double mat_b[rows*cols] = random;
      decl dynamic double mat_c[rows*cols] = 0;
      decl double scalar = random;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) @*/
/**-- (Generated by Orio) 
Best performance cost: 
  [1.355e-06, 5.71e-07, 5.09e-07, 5.32e-07, 5.1e-07, 5.1e-07, 5.07e-07, 5.08e-07, 5.15e-07, 5.06e-07, 5.1e-07, 5.1e-07, 5.1e-07, 5.12e-07, 5.13e-07, 5.14e-07, 5.12e-07, 5.11e-07, 5.18e-07, 5.05e-07, 5.1e-07, 5.1e-07, 5.09e-07, 5.07e-07, 5.03e-07, 5.03e-07, 5.12e-07, 5.13e-07, 5.11e-07, 5.07e-07, 5.09e-07, 5.05e-07, 5.09e-07, 5.07e-07, 5.05e-07, 5.03e-07, 5.03e-07, 5.12e-07, 5.05e-07, 5.09e-07, 5.11e-07, 5e-07, 5.09e-07, 5.09e-07, 5.2e-07, 5.06e-07, 5.1e-07, 5.03e-07, 5.11e-07, 5.09e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O2 
  RT1_I = 6 
  RT1_J = 6 
  U_I = 1 
  U_J = 5 
  VEC = True 
--**/


    
  int i, j, it, jt;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      regtile = (['i','j'],[RT1_I,RT1_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      for (j = 0; j <= cols-1; j++) {
        mat_c[cols * i + j] = mat_a[cols * i + j] * scalar;
      }
    }
  ) @*/
  {
    for (it=0; it<=rows-6; it=it+6) {
      register int cbv_1;
      cbv_1=cols-6;
#pragma ivdep
#pragma vector always
      for (jt=0; jt<=cbv_1; jt=jt+6) {
        mat_c[cols*it+jt]=mat_a[cols*it+jt]*scalar;
        mat_c[cols*it+(jt+1)]=mat_a[cols*it+(jt+1)]*scalar;
        mat_c[cols*it+(jt+2)]=mat_a[cols*it+(jt+2)]*scalar;
        mat_c[cols*it+(jt+3)]=mat_a[cols*it+(jt+3)]*scalar;
        mat_c[cols*it+(jt+4)]=mat_a[cols*it+(jt+4)]*scalar;
        mat_c[cols*it+(jt+5)]=mat_a[cols*it+(jt+5)]*scalar;
        mat_c[cols*(it+1)+jt]=mat_a[cols*(it+1)+jt]*scalar;
        mat_c[cols*(it+1)+(jt+1)]=mat_a[cols*(it+1)+(jt+1)]*scalar;
        mat_c[cols*(it+1)+(jt+2)]=mat_a[cols*(it+1)+(jt+2)]*scalar;
        mat_c[cols*(it+1)+(jt+3)]=mat_a[cols*(it+1)+(jt+3)]*scalar;
        mat_c[cols*(it+1)+(jt+4)]=mat_a[cols*(it+1)+(jt+4)]*scalar;
        mat_c[cols*(it+1)+(jt+5)]=mat_a[cols*(it+1)+(jt+5)]*scalar;
        mat_c[cols*(it+2)+jt]=mat_a[cols*(it+2)+jt]*scalar;
        mat_c[cols*(it+2)+(jt+1)]=mat_a[cols*(it+2)+(jt+1)]*scalar;
        mat_c[cols*(it+2)+(jt+2)]=mat_a[cols*(it+2)+(jt+2)]*scalar;
        mat_c[cols*(it+2)+(jt+3)]=mat_a[cols*(it+2)+(jt+3)]*scalar;
        mat_c[cols*(it+2)+(jt+4)]=mat_a[cols*(it+2)+(jt+4)]*scalar;
        mat_c[cols*(it+2)+(jt+5)]=mat_a[cols*(it+2)+(jt+5)]*scalar;
        mat_c[cols*(it+3)+jt]=mat_a[cols*(it+3)+jt]*scalar;
        mat_c[cols*(it+3)+(jt+1)]=mat_a[cols*(it+3)+(jt+1)]*scalar;
        mat_c[cols*(it+3)+(jt+2)]=mat_a[cols*(it+3)+(jt+2)]*scalar;
        mat_c[cols*(it+3)+(jt+3)]=mat_a[cols*(it+3)+(jt+3)]*scalar;
        mat_c[cols*(it+3)+(jt+4)]=mat_a[cols*(it+3)+(jt+4)]*scalar;
        mat_c[cols*(it+3)+(jt+5)]=mat_a[cols*(it+3)+(jt+5)]*scalar;
        mat_c[cols*(it+4)+jt]=mat_a[cols*(it+4)+jt]*scalar;
        mat_c[cols*(it+4)+(jt+1)]=mat_a[cols*(it+4)+(jt+1)]*scalar;
        mat_c[cols*(it+4)+(jt+2)]=mat_a[cols*(it+4)+(jt+2)]*scalar;
        mat_c[cols*(it+4)+(jt+3)]=mat_a[cols*(it+4)+(jt+3)]*scalar;
        mat_c[cols*(it+4)+(jt+4)]=mat_a[cols*(it+4)+(jt+4)]*scalar;
        mat_c[cols*(it+4)+(jt+5)]=mat_a[cols*(it+4)+(jt+5)]*scalar;
        mat_c[cols*(it+5)+jt]=mat_a[cols*(it+5)+jt]*scalar;
        mat_c[cols*(it+5)+(jt+1)]=mat_a[cols*(it+5)+(jt+1)]*scalar;
        mat_c[cols*(it+5)+(jt+2)]=mat_a[cols*(it+5)+(jt+2)]*scalar;
        mat_c[cols*(it+5)+(jt+3)]=mat_a[cols*(it+5)+(jt+3)]*scalar;
        mat_c[cols*(it+5)+(jt+4)]=mat_a[cols*(it+5)+(jt+4)]*scalar;
        mat_c[cols*(it+5)+(jt+5)]=mat_a[cols*(it+5)+(jt+5)]*scalar;
      }
      {
        int j;
        register int cbv_2;
        cbv_2=cols-5;
#pragma ivdep
#pragma vector always
        for (j=jt; j<=cbv_2; j=j+5) {
          mat_c[cols*it+j]=mat_a[cols*it+j]*scalar;
          mat_c[cols*(it+1)+j]=mat_a[cols*(it+1)+j]*scalar;
          mat_c[cols*(it+2)+j]=mat_a[cols*(it+2)+j]*scalar;
          mat_c[cols*(it+3)+j]=mat_a[cols*(it+3)+j]*scalar;
          mat_c[cols*(it+4)+j]=mat_a[cols*(it+4)+j]*scalar;
          mat_c[cols*(it+5)+j]=mat_a[cols*(it+5)+j]*scalar;
          mat_c[cols*it+j+1]=mat_a[cols*it+j+1]*scalar;
          mat_c[cols*(it+1)+j+1]=mat_a[cols*(it+1)+j+1]*scalar;
          mat_c[cols*(it+2)+j+1]=mat_a[cols*(it+2)+j+1]*scalar;
          mat_c[cols*(it+3)+j+1]=mat_a[cols*(it+3)+j+1]*scalar;
          mat_c[cols*(it+4)+j+1]=mat_a[cols*(it+4)+j+1]*scalar;
          mat_c[cols*(it+5)+j+1]=mat_a[cols*(it+5)+j+1]*scalar;
          mat_c[cols*it+j+2]=mat_a[cols*it+j+2]*scalar;
          mat_c[cols*(it+1)+j+2]=mat_a[cols*(it+1)+j+2]*scalar;
          mat_c[cols*(it+2)+j+2]=mat_a[cols*(it+2)+j+2]*scalar;
          mat_c[cols*(it+3)+j+2]=mat_a[cols*(it+3)+j+2]*scalar;
          mat_c[cols*(it+4)+j+2]=mat_a[cols*(it+4)+j+2]*scalar;
          mat_c[cols*(it+5)+j+2]=mat_a[cols*(it+5)+j+2]*scalar;
          mat_c[cols*it+j+3]=mat_a[cols*it+j+3]*scalar;
          mat_c[cols*(it+1)+j+3]=mat_a[cols*(it+1)+j+3]*scalar;
          mat_c[cols*(it+2)+j+3]=mat_a[cols*(it+2)+j+3]*scalar;
          mat_c[cols*(it+3)+j+3]=mat_a[cols*(it+3)+j+3]*scalar;
          mat_c[cols*(it+4)+j+3]=mat_a[cols*(it+4)+j+3]*scalar;
          mat_c[cols*(it+5)+j+3]=mat_a[cols*(it+5)+j+3]*scalar;
          mat_c[cols*it+j+4]=mat_a[cols*it+j+4]*scalar;
          mat_c[cols*(it+1)+j+4]=mat_a[cols*(it+1)+j+4]*scalar;
          mat_c[cols*(it+2)+j+4]=mat_a[cols*(it+2)+j+4]*scalar;
          mat_c[cols*(it+3)+j+4]=mat_a[cols*(it+3)+j+4]*scalar;
          mat_c[cols*(it+4)+j+4]=mat_a[cols*(it+4)+j+4]*scalar;
          mat_c[cols*(it+5)+j+4]=mat_a[cols*(it+5)+j+4]*scalar;
        }
        register int cbv_3, cbv_4;
        cbv_3=cols-((cols-(jt))%5);
        cbv_4=cols-1;
#pragma ivdep
#pragma vector always
        for (j=cbv_3; j<=cbv_4; j=j+1) {
          mat_c[cols*it+j]=mat_a[cols*it+j]*scalar;
          mat_c[cols*(it+1)+j]=mat_a[cols*(it+1)+j]*scalar;
          mat_c[cols*(it+2)+j]=mat_a[cols*(it+2)+j]*scalar;
          mat_c[cols*(it+3)+j]=mat_a[cols*(it+3)+j]*scalar;
          mat_c[cols*(it+4)+j]=mat_a[cols*(it+4)+j]*scalar;
          mat_c[cols*(it+5)+j]=mat_a[cols*(it+5)+j]*scalar;
        }
      }
    }
    for (i=it; i<=rows-1; i=i+1) {
      register int cbv_5;
      cbv_5=cols-6;
#pragma ivdep
#pragma vector always
      for (jt=0; jt<=cbv_5; jt=jt+6) {
        mat_c[cols*i+jt]=mat_a[cols*i+jt]*scalar;
        mat_c[cols*i+(jt+1)]=mat_a[cols*i+(jt+1)]*scalar;
        mat_c[cols*i+(jt+2)]=mat_a[cols*i+(jt+2)]*scalar;
        mat_c[cols*i+(jt+3)]=mat_a[cols*i+(jt+3)]*scalar;
        mat_c[cols*i+(jt+4)]=mat_a[cols*i+(jt+4)]*scalar;
        mat_c[cols*i+(jt+5)]=mat_a[cols*i+(jt+5)]*scalar;
      }
      {
        int j;
        register int cbv_6;
        cbv_6=cols-5;
#pragma ivdep
#pragma vector always
        for (j=jt; j<=cbv_6; j=j+5) {
          mat_c[cols*i+j]=mat_a[cols*i+j]*scalar;
          mat_c[cols*i+j+1]=mat_a[cols*i+j+1]*scalar;
          mat_c[cols*i+j+2]=mat_a[cols*i+j+2]*scalar;
          mat_c[cols*i+j+3]=mat_a[cols*i+j+3]*scalar;
          mat_c[cols*i+j+4]=mat_a[cols*i+j+4]*scalar;
        }
        register int cbv_7, cbv_8;
        cbv_7=cols-((cols-(jt))%5);
        cbv_8=cols-1;
#pragma ivdep
#pragma vector always
        for (j=cbv_7; j<=cbv_8; j=j+1) 
          mat_c[cols*i+j]=mat_a[cols*i+j]*scalar;
      }
    }
  }
/*@ end @*/
/*@ end @*/

  
}
