#include "../../linear_algebra.h"


void transpose_matrix(TYPE* mat_a, int rows_a, int cols_a, TYPE* mat_c) {
 

/*@ begin PerfTuning (

 def build {
   arg build_command = 'gcc';
   #arg libs = '-lrt';  # Only needed on linux
 } 

 def performance_counter {
   arg repetitions = 5;
 }

 def performance_params {  
  param U_I[] = range(1,31);
  param U_J[] = range(1,31);

  param VEC[] = [False,True];

  param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];
  constraint unroll_limit = ((U_I == 1) or (U_J == 1));

 }
 
 def input_params {
  let N = [10, 20];
  param rows_a[] = N;
  param cols_a[] = N;
 }
 
 def input_vars {
   decl dynamic double mat_a[rows_a*cols_a] = random;
   decl dynamic double mat_c[rows_a*cols_a] = 0;
 }
 
 def search {
   arg algorithm = 'Exhaustive';
 }

) @*/
if ((rows_a<=10) && (cols_a<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.678e-06, 5.72e-07, 4.82e-07, 4.73e-07, 4.7e-07] 
Tuned for specific problem sizes: 
  cols_a = 10 
  rows_a = 10 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-10; i=i+10) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%10); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=10) && (cols_a<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.63e-06, 8.96e-07, 8.5e-07, 8.36e-07, 8.33e-07] 
Tuned for specific problem sizes: 
  cols_a = 20 
  rows_a = 10 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 5 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-5; i=i+5) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%5); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=20) && (cols_a<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.335e-06, 8.9e-07, 7.79e-07, 7.74e-07, 7.75e-07] 
Tuned for specific problem sizes: 
  cols_a = 10 
  rows_a = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 20 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-20; i=i+20) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    a_row=cols_a*(i+15);
    a_row=cols_a*(i+16);
    a_row=cols_a*(i+17);
    a_row=cols_a*(i+18);
    a_row=cols_a*(i+19);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
      mat_c[rows_a*j+i+15]=mat_a[a_row+j];
      mat_c[rows_a*j+i+16]=mat_a[a_row+j];
      mat_c[rows_a*j+i+17]=mat_a[a_row+j];
      mat_c[rows_a*j+i+18]=mat_a[a_row+j];
      mat_c[rows_a*j+i+19]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%20); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=20) && (cols_a<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.415e-06, 1.518e-06, 1.372e-06, 1.369e-06, 1.371e-06] 
Tuned for specific problem sizes: 
  cols_a = 20 
  rows_a = 20 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-10; i=i+10) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%10); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
}
/*@ end @*/

}
