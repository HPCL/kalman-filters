/*
 * linear_algebra.c
 * simple code for matrix funcitons
 * many of the functions in this "library" are in the various subdirs for tuning purposes
 
 * Brian J Gravelle
 * ix.cs.uoregon.edu/~gravelle
 * gravelle@cs.uoregon.edu

 * See LICENSE file for licensing information and boring legal stuff

 * If by some miricale you find this software useful, thanks are accepted in
 * the form of chocolate, coffee, or introductions to potential employers.

*/

#include "../linear_algebra.h"
#include <math.h>


void print_matrix(TYPE* mat_a, int rows_a, int cols_a) {

  int i, j;

  for (i = 0; i < rows_a; i++) {
    for (j = 0; j < cols_a; j++) {
      printf("%.4f ", mat_a[i * cols_a + j]);
    }
    printf("\n\n");
  }
}


//get inverse matrix
//pre matrix a has been created and filled with data
//     matrices must be square and the same size
//params mat_a - matrix to invert
//        n -  the matrix side size
//post mat_c has the inverse matrix of mat_a
//TODO clean up and use a better algo
void invert_matrix(TYPE* mat_a, int n, TYPE* mat_c) {

  TYPE cofactor[n*n];
  TYPE adjoint[n*n];
  TYPE det;

  if (n == 1) {
    mat_c[0] = 1 / mat_a[0];

  } else {
    det = determinant_matrix(mat_a, n);
    det = 1 / det;
    // if( isnan(det) )
    // {
    //   printf("\n\nERROR NAN\n");
    //   print_matrix(mat_a, n, n);
    //   printf("\n\n");
    // }
    cofactor_matrix(mat_a, n, cofactor);
    transpose_matrix(cofactor, n, n, adjoint);
    multiply_matrix_by_scalar(adjoint, n, n, det, mat_c);
  }
}

//get matrix determinant recursively
//pre matrix a has been created and filled with data
//     matrix must be square
//params mat_a - matrix to invert
//        n -  the matrix side size
//returms determinant of matrix a
TYPE determinant_matrix_recur(TYPE* mat_a, int n) {

  TYPE det = 0;
  int i, j, k, skip;
  int n_b = n-1;
  int size_b = (n-1) * (n-1);
  int size_a = n * n;
  int sign = 1;
  TYPE mat_b[size_b];

  if(n == 2) {
    det = (mat_a[0] * mat_a[3]) - (mat_a[1] * mat_a[2]);

  } else {

    for (i = 0; i < n; i++) {

      if(mat_a[i] != 0){
        k = 0;
        skip = i + n;

        for(j = n; j < size_a; j++) {
          if(j != skip)
            mat_b[k++] = mat_a[j];
          else
            skip += n;
        }

        det += sign * mat_a[i] * determinant_matrix(mat_b, n_b);
      } // if mat_a[i] != 0
      
      sign = sign * -1;
    } // for loop

  } //else 

  return det;
}

//set a matrix to zero
//pre matrix_a has been allocated to rows_a x cols_a
//post mat_a is all zeros
void set_zero(TYPE* mat_a, int rows_a, int cols_a) {
  int i, j;
  int a_row;

  for (i = 0; i < rows_a; i++) {
    a_row = cols_a * i;
    for (j = 0; j < cols_a; j++) {
      mat_a[a_row + j] = 0;
    }
  }
}

//set a matrix to the identity
//pre matrix_a has been allocated to rows_a x cols_a
//post mat_a has ones in the diagonal and zeros elsewhere
void set_identity(TYPE* mat_a, int rows_a, int cols_a) {
  int i, j;
  int a_row;

  for (i = 0; i < rows_a; i++) {
    a_row = cols_a * i;
    for (j = 0; j < cols_a; j++) {
      mat_a[a_row + j] = (double)(i == j);
    }
  }
}


//deep copy of a to b
void copy_mat(TYPE* mat_a, TYPE* mat_c, int total_elms) {
  int i;
  for (i = 0; i < total_elms; i++)
    mat_c[i] = mat_a[i];
}

//returns abs(a)
//TODO make a macro?
TYPE get_abs(TYPE a) {
  return (((a < 0) * -2) + 1) * a;
  
  // return (a < 0) ? -a : a;

}
void add_matrix(TYPE* mat_a, int rows, int cols, TYPE* mat_b, TYPE* mat_c)  {

/*@ begin PerfTuning (

 def build {
   arg build_command = 'gcc';
   #arg libs = '-lrt';  # Only needed on linux
 } 

 def performance_counter {
   arg repetitions = 5;
 }

 def performance_params {  
  param U_I[] = range(1,31);
  param U_J[] = range(1,31);

  param VEC[] = [False,True];

  param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];
  constraint unroll_limit = ((U_I == 1) or (U_J == 1));

 }
 
 def input_params {
  let N = [6, 10, 15, 20];
  param rows[] = N;
  param cols[] = N;
 }
 
 def input_vars {
   decl dynamic double mat_a[rows*cols] = random;
   decl dynamic double mat_b[rows*cols] = random;
   decl dynamic double mat_c[rows*cols] = 0;
 }
 
 def search {
   arg algorithm = 'Exhaustive';
 }

) @*/
if ((rows<=6) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.14e-06, 4.9e-07, 4.02e-07, 3.94e-07, 3.93e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 3 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-3; i=i+3) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
    }
  }
  for (i=rows-((rows-(0))%3); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=6) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.505e-06, 6.77e-07, 5.36e-07, 5.37e-07, 5.35e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 6 
  U_J = 1 
  VEC = False 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-6; i=i+6) {
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
    }
  }
  for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) 
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
}
/*@ end @*/
} else if ((rows<=6) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.639e-06, 7.97e-07, 6.81e-07, 6.76e-07, 6.65e-07] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 6 
  U_J = 1 
  VEC = False 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-6; i=i+6) {
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
    }
  }
  for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) 
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
}
/*@ end @*/
} else if ((rows<=6) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.961e-06, 1.004e-06, 9.03e-07, 9.04e-07, 8.97e-07] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 6 
  U_J = 1 
  VEC = False 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-6; i=i+6) {
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
    }
  }
  for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) 
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
}
/*@ end @*/
} else if ((rows<=10) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.61e-06, 6.44e-07, 5.46e-07, 5.35e-07, 5.35e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-10; i=i+10) {
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
    }
  }
  for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) 
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
}
/*@ end @*/
} else if ((rows<=10) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.863e-06, 8.97e-07, 7.87e-07, 7.79e-07, 7.78e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-10; i=i+10) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
    }
  }
  for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=10) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.97e-06, 1.158e-06, 1.005e-06, 9.97e-07, 1e-06] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-10; i=i+10) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
    }
  }
  for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=10) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.833e-06, 1.564e-06, 1.406e-06, 1.396e-06, 1.401e-06] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 1 
  U_J = 19 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
for (i=0; i<=rows-1; i++ ) {
  {
    int j;
    register int cbv_1;
    cbv_1=cols-19;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j=j+19) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*i+j+1]=mat_a[cols*i+j+1]+mat_b[cols*i+j+1];
      mat_c[cols*i+j+2]=mat_a[cols*i+j+2]+mat_b[cols*i+j+2];
      mat_c[cols*i+j+3]=mat_a[cols*i+j+3]+mat_b[cols*i+j+3];
      mat_c[cols*i+j+4]=mat_a[cols*i+j+4]+mat_b[cols*i+j+4];
      mat_c[cols*i+j+5]=mat_a[cols*i+j+5]+mat_b[cols*i+j+5];
      mat_c[cols*i+j+6]=mat_a[cols*i+j+6]+mat_b[cols*i+j+6];
      mat_c[cols*i+j+7]=mat_a[cols*i+j+7]+mat_b[cols*i+j+7];
      mat_c[cols*i+j+8]=mat_a[cols*i+j+8]+mat_b[cols*i+j+8];
      mat_c[cols*i+j+9]=mat_a[cols*i+j+9]+mat_b[cols*i+j+9];
      mat_c[cols*i+j+10]=mat_a[cols*i+j+10]+mat_b[cols*i+j+10];
      mat_c[cols*i+j+11]=mat_a[cols*i+j+11]+mat_b[cols*i+j+11];
      mat_c[cols*i+j+12]=mat_a[cols*i+j+12]+mat_b[cols*i+j+12];
      mat_c[cols*i+j+13]=mat_a[cols*i+j+13]+mat_b[cols*i+j+13];
      mat_c[cols*i+j+14]=mat_a[cols*i+j+14]+mat_b[cols*i+j+14];
      mat_c[cols*i+j+15]=mat_a[cols*i+j+15]+mat_b[cols*i+j+15];
      mat_c[cols*i+j+16]=mat_a[cols*i+j+16]+mat_b[cols*i+j+16];
      mat_c[cols*i+j+17]=mat_a[cols*i+j+17]+mat_b[cols*i+j+17];
      mat_c[cols*i+j+18]=mat_a[cols*i+j+18]+mat_b[cols*i+j+18];
    }
    register int cbv_2, cbv_3;
    cbv_2=cols-((cols-(0))%19);
    cbv_3=cols-1;
#pragma ivdep
#pragma vector always
    for (j=cbv_2; j<=cbv_3; j=j+1) 
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
  }
}
/*@ end @*/
} else if ((rows<=15) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.508e-06, 8.68e-07, 7.19e-07, 7.09e-07, 7.06e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 5 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-5; i=i+5) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
    }
  }
  for (i=rows-((rows-(0))%5); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=15) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [3.594e-06, 1.235e-06, 1.075e-06, 1.068e-06, 1.083e-06] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 15 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-15; i=i+15) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
      mat_c[cols*(i+10)+j]=mat_a[cols*(i+10)+j]+mat_b[cols*(i+10)+j];
      mat_c[cols*(i+11)+j]=mat_a[cols*(i+11)+j]+mat_b[cols*(i+11)+j];
      mat_c[cols*(i+12)+j]=mat_a[cols*(i+12)+j]+mat_b[cols*(i+12)+j];
      mat_c[cols*(i+13)+j]=mat_a[cols*(i+13)+j]+mat_b[cols*(i+13)+j];
      mat_c[cols*(i+14)+j]=mat_a[cols*(i+14)+j]+mat_b[cols*(i+14)+j];
    }
  }
  for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=15) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.783e-06, 1.605e-06, 1.42e-06, 1.418e-06, 1.415e-06] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 15 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-15; i=i+15) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
      mat_c[cols*(i+10)+j]=mat_a[cols*(i+10)+j]+mat_b[cols*(i+10)+j];
      mat_c[cols*(i+11)+j]=mat_a[cols*(i+11)+j]+mat_b[cols*(i+11)+j];
      mat_c[cols*(i+12)+j]=mat_a[cols*(i+12)+j]+mat_b[cols*(i+12)+j];
      mat_c[cols*(i+13)+j]=mat_a[cols*(i+13)+j]+mat_b[cols*(i+13)+j];
      mat_c[cols*(i+14)+j]=mat_a[cols*(i+14)+j]+mat_b[cols*(i+14)+j];
    }
  }
  for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=15) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [3.801e-06, 2.136e-06, 1.98e-06, 1.975e-06, 1.951e-06] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 15 
  U_J = 1 
  VEC = False 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-15; i=i+15) {
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
      mat_c[cols*(i+10)+j]=mat_a[cols*(i+10)+j]+mat_b[cols*(i+10)+j];
      mat_c[cols*(i+11)+j]=mat_a[cols*(i+11)+j]+mat_b[cols*(i+11)+j];
      mat_c[cols*(i+12)+j]=mat_a[cols*(i+12)+j]+mat_b[cols*(i+12)+j];
      mat_c[cols*(i+13)+j]=mat_a[cols*(i+13)+j]+mat_b[cols*(i+13)+j];
      mat_c[cols*(i+14)+j]=mat_a[cols*(i+14)+j]+mat_b[cols*(i+14)+j];
    }
  }
  for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) 
    for (j=0; j<=cols-1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
}
/*@ end @*/
} else if ((rows<=20) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.901e-06, 1.076e-06, 8.87e-07, 8.88e-07, 8.86e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 20 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-20; i=i+20) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
      mat_c[cols*(i+10)+j]=mat_a[cols*(i+10)+j]+mat_b[cols*(i+10)+j];
      mat_c[cols*(i+11)+j]=mat_a[cols*(i+11)+j]+mat_b[cols*(i+11)+j];
      mat_c[cols*(i+12)+j]=mat_a[cols*(i+12)+j]+mat_b[cols*(i+12)+j];
      mat_c[cols*(i+13)+j]=mat_a[cols*(i+13)+j]+mat_b[cols*(i+13)+j];
      mat_c[cols*(i+14)+j]=mat_a[cols*(i+14)+j]+mat_b[cols*(i+14)+j];
      mat_c[cols*(i+15)+j]=mat_a[cols*(i+15)+j]+mat_b[cols*(i+15)+j];
      mat_c[cols*(i+16)+j]=mat_a[cols*(i+16)+j]+mat_b[cols*(i+16)+j];
      mat_c[cols*(i+17)+j]=mat_a[cols*(i+17)+j]+mat_b[cols*(i+17)+j];
      mat_c[cols*(i+18)+j]=mat_a[cols*(i+18)+j]+mat_b[cols*(i+18)+j];
      mat_c[cols*(i+19)+j]=mat_a[cols*(i+19)+j]+mat_b[cols*(i+19)+j];
    }
  }
  for (i=rows-((rows-(0))%20); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=20) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [3.373e-06, 1.591e-06, 1.429e-06, 1.408e-06, 1.399e-06] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-10; i=i+10) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
    }
  }
  for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=20) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [3.896e-06, 2.039e-06, 1.815e-06, 1.804e-06, 1.803e-06] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-10; i=i+10) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
    }
  }
  for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
} else if ((rows<=20) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [4.367e-06, 2.764e-06, 2.616e-06, 2.59e-06, 2.578e-06] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


int i, j;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
)
  for (i = 0; i <= rows-1; i++) {
    for (j = 0; j <= cols-1; j++) {
      mat_c[ cols * i + j] = mat_a[ cols * i + j] + mat_b[ cols * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows-10; i=i+10) {
    register int cbv_1;
    cbv_1=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
      mat_c[cols*(i+1)+j]=mat_a[cols*(i+1)+j]+mat_b[cols*(i+1)+j];
      mat_c[cols*(i+2)+j]=mat_a[cols*(i+2)+j]+mat_b[cols*(i+2)+j];
      mat_c[cols*(i+3)+j]=mat_a[cols*(i+3)+j]+mat_b[cols*(i+3)+j];
      mat_c[cols*(i+4)+j]=mat_a[cols*(i+4)+j]+mat_b[cols*(i+4)+j];
      mat_c[cols*(i+5)+j]=mat_a[cols*(i+5)+j]+mat_b[cols*(i+5)+j];
      mat_c[cols*(i+6)+j]=mat_a[cols*(i+6)+j]+mat_b[cols*(i+6)+j];
      mat_c[cols*(i+7)+j]=mat_a[cols*(i+7)+j]+mat_b[cols*(i+7)+j];
      mat_c[cols*(i+8)+j]=mat_a[cols*(i+8)+j]+mat_b[cols*(i+8)+j];
      mat_c[cols*(i+9)+j]=mat_a[cols*(i+9)+j]+mat_b[cols*(i+9)+j];
    }
  }
  for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
    register int cbv_2;
    cbv_2=cols-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[cols*i+j]=mat_a[cols*i+j]+mat_b[cols*i+j];
    }
  }
}
/*@ end @*/
}
/*@ end @*/

}
// not tuned yet

void cofactor_matrix(TYPE* mat_a, int n, TYPE* mat_c) {


  /* begin PerfTuning (

    def build {
      arg build_command = 'gcc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 5;
    }

    def performance_params {  
      param U_I[] = range(1,31);
      param U_J[] = range(1,31);
      param U_R[] = range(1,31);

      param VEC[] = [False,True];

      param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];

    }

    def input_params {
      let N = [6, 10, 15, 20];
      param n[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[n*n] = random;
      decl dynamic double mat_c[n*n] = 0;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) */

  TYPE det = 0;
  int i, j, r, c, k, row, rr;
  int n_b = n-1;
  int size_b = (n-1) * (n-1);
  int size_a = n * n;
  int sign = 1;
  TYPE mat_b[size_b];



  /* begin Loop (  
  transform Composite(
    unrolljam = (['i','j','r'],[U_I,U_J,U_R]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= n-1; i++) {
    row = n * i;
    for (j = 0; j <= n-1; j++) {

        k = 0;
        for (r = 0; r <= n-1; r++) {
          if(r != i){
            rr = n * r;
            for (c = 0; c <= n-1; c++) {
              if(c != j) mat_b[k++] = mat_a[rr + c];
            }
          }
        }

      det = determinant_matrix(mat_b, n_b);
      mat_c[row + j] = sign * det;
      sign = sign * -1;
    }
    sign = sign * -1;
  }
  ) */

  for (i = 0; i <= n-1; i++) {
    row = n * i;
    for (j = 0; j <= n-1; j++) {

        k = 0;
        for (r = 0; r <= n-1; r++) {
          if(r != i){
            rr = n * r;
            for (c = 0; c <= n-1; c++) {
              if(c != j) mat_b[k++] = mat_a[rr + c];
            }
          }
        }

      det = determinant_matrix(mat_b, n_b);
      mat_c[row + j] = sign * det;
      sign = sign * -1;
    }
    sign = sign * -1;
  }


/* end @*/
/* end @*/

}



int compute_LUP(TYPE* mat_a, TYPE* L, TYPE* U, TYPE* P, int n) {
  int i, j, k, ind_max, curr_row, next_row;
  int cnt_pivots = 0;
  int size_a = n*n;
  TYPE tolerance = 5E-300;
  TYPE max_a, abs_a, coeff;
  TYPE temp_row[n];

  set_identity(P, n, n);
  set_identity(L, n, n);
  copy_mat(mat_a, U, size_a);

  for(i = 0; i < n; i++) {
    curr_row = i * n;
    max_a = get_abs(U[curr_row + i]);
    ind_max = i;

    for (j = i+1; j < n; j++) {
      abs_a = get_abs(U[j * n + i]);
      if (abs_a > max_a) {
        max_a = abs_a;
        ind_max = j;
      }
    }
    
    if (max_a < tolerance) return -1;
    
    if (ind_max != i) {
      cnt_pivots++;
      ind_max *= n;

      copy_mat(&P[curr_row], temp_row, n);
      copy_mat(&P[ind_max], &P[curr_row], n);
      copy_mat(temp_row, &P[ind_max], n);

      copy_mat(&U[curr_row], temp_row, n);
      copy_mat(&U[ind_max], &U[curr_row], n);
      copy_mat(temp_row, &U[ind_max], n);
    }

    for(j = i+1; j < n; j++) {
      next_row = j * n;
      coeff = (U[next_row+i]/U[curr_row+i]);
      L[next_row+i] = coeff;
      for (k = i; k < n; k++) {
        U[next_row + k] -= coeff * U[curr_row + k];
      }
    }

  } //end main for

  return cnt_pivots;
}



int compute_LUP_inline(TYPE* mat_a, TYPE* L, TYPE* U, TYPE* P, int n) {
 

  /*@ begin PerfTuning (

    def build {
      arg build_command = 'gcc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 5;
    }

    def performance_params {  
      param U_I[] = range(1,31);
      param U_J[] = range(1,31);
      # param U_K[] = range(1,31);

      # param VEC[] = [False,True];

      # param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];

      # constraint unroll_limit = ((U_I == 1) or (U_J == 1));

    }

    def input_params {
      let N = [100];
      param n[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[n*n] = random;
      decl dynamic double L[n*n] = 0;
      decl dynamic double U[n*n] = 0;
      decl dynamic double P[n*n] = 0;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) @*/
/**-- (Generated by Orio) 
Best performance cost: 
  [0.000135761, 0.000133519, 0.000132624, 0.000132662, 0.000132522] 
Tuned for specific problem sizes: 
  n = 100 
Best performance parameters: 
  U_I = 10 
  U_J = 5 
--**/



  int i, j, k, ind_max;
  int i2, j2, k2;
  int ii, jj, kk;
  int iii, jjj, kkk;

  int cnt_pivots = 0;
  int size_a = n*n;
  double tolerance = 5E-300;
  double max_a, abs_a, coeff;
  double temp_row[n];

  
  /*@ begin Loop ( 

  transform Composite(
    unrolljam = (['i2','j2'],[U_I,U_J])
  )
  for (i2 = 0; i2 <= n-1; i2++) {
    for (j2 = 0; j2 <= n-1; j2++) {
      if(i2 == j2)
        P[n * i2 + j2] = 1;
      else
        P[n * i2 + j2]= 0;
    }
  }


  transform Composite(
    unrolljam = (['i2'],[U_I])
  )
  for (i2 = 0; i2 <= n-1; i2++) {
    for (j2 = 0; j2 <= n-1; j2++) {
      if(i2 == j2)
        L[n * i2 + j2] = 1;
      else
        L[n * i2 + j2]= 0;
    }
  }

  transform Composite(
    unrolljam = (['i2'],[U_I])
  )
  for (i2 = 0; i2 <= size_a-1; i2++)
    U[i2] = mat_a[i2];


  for(i = 0; i <= n-1; i++) {
    if(U[i * n + i] > 0) max_a = U[i * n + i]; 
    else max_a = 0 - U[i * n + i];
    ind_max = i;

    for (j = i+1; j <= n-1; j++) {
      if(U[j * n + i] > 0) abs_a = U[j * n + i]; 
      else abs_a = 0 - U[j * n + i];
      if (abs_a > max_a) {
        max_a = abs_a;
        ind_max = j;
      }
    }
    
    if (max_a <= tolerance) {
      cnt_pivots = 0 - 1;
      break;
    }


    cnt_pivots++;

    for (k = 0; k <= n-1; k++)
      temp_row[k] = P[i * n+k];
    for (k = 0; k <= n-1; k++)
      P[i * n+k] = P[ind_max * n+k];
    for (k = 0; k <= n-1; k++)
      P[ind_max * n+k] = temp_row[k];


    for (k = 0; k <= n-1; k++)
      temp_row[k] = U[i * n+k];
    for (k = 0; k <= n-1; k++)
      U[i * n+k] = U[ind_max * n+k];
    for (k = 0; k <= n-1; k++)
      U[ind_max * n+k] = temp_row[k];


    for(j = i+1; j <= n-1; j++) {
      coeff = (U[j * n+i]/U[i * n+i]);
      L[j * n+i] = coeff;
      for (k = i; k <= n-1; k++) {
        U[j * n + k] -= coeff * U[i * n + k];
      }
    }

  } //end main for



) @*/
  {
    int i2;
    for (i2=0; i2<=n-10; i2=i2+10) {
      int j2;
      for (j2=0; j2<=n-5; j2=j2+5) {
        if (i2==j2) 
          P[n*i2+j2]=1;
        else 
          P[n*i2+j2]=0;
        if (i2==(j2+1)) 
          P[n*i2+j2+1]=1;
        else 
          P[n*i2+j2+1]=0;
        if (i2==(j2+2)) 
          P[n*i2+j2+2]=1;
        else 
          P[n*i2+j2+2]=0;
        if (i2==(j2+3)) 
          P[n*i2+j2+3]=1;
        else 
          P[n*i2+j2+3]=0;
        if (i2==(j2+4)) 
          P[n*i2+j2+4]=1;
        else 
          P[n*i2+j2+4]=0;
        if ((i2+1)==j2) 
          P[n*(i2+1)+j2]=1;
        else 
          P[n*(i2+1)+j2]=0;
        if ((i2+1)==(j2+1)) 
          P[n*(i2+1)+j2+1]=1;
        else 
          P[n*(i2+1)+j2+1]=0;
        if ((i2+1)==(j2+2)) 
          P[n*(i2+1)+j2+2]=1;
        else 
          P[n*(i2+1)+j2+2]=0;
        if ((i2+1)==(j2+3)) 
          P[n*(i2+1)+j2+3]=1;
        else 
          P[n*(i2+1)+j2+3]=0;
        if ((i2+1)==(j2+4)) 
          P[n*(i2+1)+j2+4]=1;
        else 
          P[n*(i2+1)+j2+4]=0;
        if ((i2+2)==j2) 
          P[n*(i2+2)+j2]=1;
        else 
          P[n*(i2+2)+j2]=0;
        if ((i2+2)==(j2+1)) 
          P[n*(i2+2)+j2+1]=1;
        else 
          P[n*(i2+2)+j2+1]=0;
        if ((i2+2)==(j2+2)) 
          P[n*(i2+2)+j2+2]=1;
        else 
          P[n*(i2+2)+j2+2]=0;
        if ((i2+2)==(j2+3)) 
          P[n*(i2+2)+j2+3]=1;
        else 
          P[n*(i2+2)+j2+3]=0;
        if ((i2+2)==(j2+4)) 
          P[n*(i2+2)+j2+4]=1;
        else 
          P[n*(i2+2)+j2+4]=0;
        if ((i2+3)==j2) 
          P[n*(i2+3)+j2]=1;
        else 
          P[n*(i2+3)+j2]=0;
        if ((i2+3)==(j2+1)) 
          P[n*(i2+3)+j2+1]=1;
        else 
          P[n*(i2+3)+j2+1]=0;
        if ((i2+3)==(j2+2)) 
          P[n*(i2+3)+j2+2]=1;
        else 
          P[n*(i2+3)+j2+2]=0;
        if ((i2+3)==(j2+3)) 
          P[n*(i2+3)+j2+3]=1;
        else 
          P[n*(i2+3)+j2+3]=0;
        if ((i2+3)==(j2+4)) 
          P[n*(i2+3)+j2+4]=1;
        else 
          P[n*(i2+3)+j2+4]=0;
        if ((i2+4)==j2) 
          P[n*(i2+4)+j2]=1;
        else 
          P[n*(i2+4)+j2]=0;
        if ((i2+4)==(j2+1)) 
          P[n*(i2+4)+j2+1]=1;
        else 
          P[n*(i2+4)+j2+1]=0;
        if ((i2+4)==(j2+2)) 
          P[n*(i2+4)+j2+2]=1;
        else 
          P[n*(i2+4)+j2+2]=0;
        if ((i2+4)==(j2+3)) 
          P[n*(i2+4)+j2+3]=1;
        else 
          P[n*(i2+4)+j2+3]=0;
        if ((i2+4)==(j2+4)) 
          P[n*(i2+4)+j2+4]=1;
        else 
          P[n*(i2+4)+j2+4]=0;
        if ((i2+5)==j2) 
          P[n*(i2+5)+j2]=1;
        else 
          P[n*(i2+5)+j2]=0;
        if ((i2+5)==(j2+1)) 
          P[n*(i2+5)+j2+1]=1;
        else 
          P[n*(i2+5)+j2+1]=0;
        if ((i2+5)==(j2+2)) 
          P[n*(i2+5)+j2+2]=1;
        else 
          P[n*(i2+5)+j2+2]=0;
        if ((i2+5)==(j2+3)) 
          P[n*(i2+5)+j2+3]=1;
        else 
          P[n*(i2+5)+j2+3]=0;
        if ((i2+5)==(j2+4)) 
          P[n*(i2+5)+j2+4]=1;
        else 
          P[n*(i2+5)+j2+4]=0;
        if ((i2+6)==j2) 
          P[n*(i2+6)+j2]=1;
        else 
          P[n*(i2+6)+j2]=0;
        if ((i2+6)==(j2+1)) 
          P[n*(i2+6)+j2+1]=1;
        else 
          P[n*(i2+6)+j2+1]=0;
        if ((i2+6)==(j2+2)) 
          P[n*(i2+6)+j2+2]=1;
        else 
          P[n*(i2+6)+j2+2]=0;
        if ((i2+6)==(j2+3)) 
          P[n*(i2+6)+j2+3]=1;
        else 
          P[n*(i2+6)+j2+3]=0;
        if ((i2+6)==(j2+4)) 
          P[n*(i2+6)+j2+4]=1;
        else 
          P[n*(i2+6)+j2+4]=0;
        if ((i2+7)==j2) 
          P[n*(i2+7)+j2]=1;
        else 
          P[n*(i2+7)+j2]=0;
        if ((i2+7)==(j2+1)) 
          P[n*(i2+7)+j2+1]=1;
        else 
          P[n*(i2+7)+j2+1]=0;
        if ((i2+7)==(j2+2)) 
          P[n*(i2+7)+j2+2]=1;
        else 
          P[n*(i2+7)+j2+2]=0;
        if ((i2+7)==(j2+3)) 
          P[n*(i2+7)+j2+3]=1;
        else 
          P[n*(i2+7)+j2+3]=0;
        if ((i2+7)==(j2+4)) 
          P[n*(i2+7)+j2+4]=1;
        else 
          P[n*(i2+7)+j2+4]=0;
        if ((i2+8)==j2) 
          P[n*(i2+8)+j2]=1;
        else 
          P[n*(i2+8)+j2]=0;
        if ((i2+8)==(j2+1)) 
          P[n*(i2+8)+j2+1]=1;
        else 
          P[n*(i2+8)+j2+1]=0;
        if ((i2+8)==(j2+2)) 
          P[n*(i2+8)+j2+2]=1;
        else 
          P[n*(i2+8)+j2+2]=0;
        if ((i2+8)==(j2+3)) 
          P[n*(i2+8)+j2+3]=1;
        else 
          P[n*(i2+8)+j2+3]=0;
        if ((i2+8)==(j2+4)) 
          P[n*(i2+8)+j2+4]=1;
        else 
          P[n*(i2+8)+j2+4]=0;
        if ((i2+9)==j2) 
          P[n*(i2+9)+j2]=1;
        else 
          P[n*(i2+9)+j2]=0;
        if ((i2+9)==(j2+1)) 
          P[n*(i2+9)+j2+1]=1;
        else 
          P[n*(i2+9)+j2+1]=0;
        if ((i2+9)==(j2+2)) 
          P[n*(i2+9)+j2+2]=1;
        else 
          P[n*(i2+9)+j2+2]=0;
        if ((i2+9)==(j2+3)) 
          P[n*(i2+9)+j2+3]=1;
        else 
          P[n*(i2+9)+j2+3]=0;
        if ((i2+9)==(j2+4)) 
          P[n*(i2+9)+j2+4]=1;
        else 
          P[n*(i2+9)+j2+4]=0;
      }
      for (j2=n-((n-(0))%5); j2<=n-1; j2=j2+1) {
        if (i2==j2) 
          P[n*i2+j2]=1;
        else 
          P[n*i2+j2]=0;
        if ((i2+1)==j2) 
          P[n*(i2+1)+j2]=1;
        else 
          P[n*(i2+1)+j2]=0;
        if ((i2+2)==j2) 
          P[n*(i2+2)+j2]=1;
        else 
          P[n*(i2+2)+j2]=0;
        if ((i2+3)==j2) 
          P[n*(i2+3)+j2]=1;
        else 
          P[n*(i2+3)+j2]=0;
        if ((i2+4)==j2) 
          P[n*(i2+4)+j2]=1;
        else 
          P[n*(i2+4)+j2]=0;
        if ((i2+5)==j2) 
          P[n*(i2+5)+j2]=1;
        else 
          P[n*(i2+5)+j2]=0;
        if ((i2+6)==j2) 
          P[n*(i2+6)+j2]=1;
        else 
          P[n*(i2+6)+j2]=0;
        if ((i2+7)==j2) 
          P[n*(i2+7)+j2]=1;
        else 
          P[n*(i2+7)+j2]=0;
        if ((i2+8)==j2) 
          P[n*(i2+8)+j2]=1;
        else 
          P[n*(i2+8)+j2]=0;
        if ((i2+9)==j2) 
          P[n*(i2+9)+j2]=1;
        else 
          P[n*(i2+9)+j2]=0;
      }
    }
    for (i2=n-((n-(0))%10); i2<=n-1; i2=i2+1) {
      int j2;
      for (j2=0; j2<=n-5; j2=j2+5) {
        if (i2==j2) 
          P[n*i2+j2]=1;
        else 
          P[n*i2+j2]=0;
        if (i2==(j2+1)) 
          P[n*i2+j2+1]=1;
        else 
          P[n*i2+j2+1]=0;
        if (i2==(j2+2)) 
          P[n*i2+j2+2]=1;
        else 
          P[n*i2+j2+2]=0;
        if (i2==(j2+3)) 
          P[n*i2+j2+3]=1;
        else 
          P[n*i2+j2+3]=0;
        if (i2==(j2+4)) 
          P[n*i2+j2+4]=1;
        else 
          P[n*i2+j2+4]=0;
      }
      for (j2=n-((n-(0))%5); j2<=n-1; j2=j2+1) 
        if (i2==j2) 
          P[n*i2+j2]=1;
        else 
          P[n*i2+j2]=0;
    }
  }
  {
    int i2;
    for (i2=0; i2<=n-10; i2=i2+10) {
      for (j2=0; j2<=n-1; j2++ ) {
        if (i2==j2) 
          L[n*i2+j2]=1;
        else 
          L[n*i2+j2]=0;
        if ((i2+1)==j2) 
          L[n*(i2+1)+j2]=1;
        else 
          L[n*(i2+1)+j2]=0;
        if ((i2+2)==j2) 
          L[n*(i2+2)+j2]=1;
        else 
          L[n*(i2+2)+j2]=0;
        if ((i2+3)==j2) 
          L[n*(i2+3)+j2]=1;
        else 
          L[n*(i2+3)+j2]=0;
        if ((i2+4)==j2) 
          L[n*(i2+4)+j2]=1;
        else 
          L[n*(i2+4)+j2]=0;
        if ((i2+5)==j2) 
          L[n*(i2+5)+j2]=1;
        else 
          L[n*(i2+5)+j2]=0;
        if ((i2+6)==j2) 
          L[n*(i2+6)+j2]=1;
        else 
          L[n*(i2+6)+j2]=0;
        if ((i2+7)==j2) 
          L[n*(i2+7)+j2]=1;
        else 
          L[n*(i2+7)+j2]=0;
        if ((i2+8)==j2) 
          L[n*(i2+8)+j2]=1;
        else 
          L[n*(i2+8)+j2]=0;
        if ((i2+9)==j2) 
          L[n*(i2+9)+j2]=1;
        else 
          L[n*(i2+9)+j2]=0;
      }
    }
    for (i2=n-((n-(0))%10); i2<=n-1; i2=i2+1) 
      for (j2=0; j2<=n-1; j2++ ) {
        if (i2==j2) 
          L[n*i2+j2]=1;
        else 
          L[n*i2+j2]=0;
      }
  }
  {
    int i2;
    for (i2=0; i2<=size_a-10; i2=i2+10) {
      U[i2]=mat_a[i2];
      U[(i2+1)]=mat_a[(i2+1)];
      U[(i2+2)]=mat_a[(i2+2)];
      U[(i2+3)]=mat_a[(i2+3)];
      U[(i2+4)]=mat_a[(i2+4)];
      U[(i2+5)]=mat_a[(i2+5)];
      U[(i2+6)]=mat_a[(i2+6)];
      U[(i2+7)]=mat_a[(i2+7)];
      U[(i2+8)]=mat_a[(i2+8)];
      U[(i2+9)]=mat_a[(i2+9)];
    }
    for (i2=size_a-((size_a-(0))%10); i2<=size_a-1; i2=i2+1) 
      U[i2]=mat_a[i2];
  }
  for (i=0; i<=n-1; i++ ) {
    if (U[i*n+i]>0) 
      max_a=U[i*n+i];
    else 
      max_a=0-U[i*n+i];
    ind_max=i;
    for (j=i+1; j<=n-1; j++ ) {
      if (U[j*n+i]>0) 
        abs_a=U[j*n+i];
      else 
        abs_a=0-U[j*n+i];
      if (abs_a>max_a) {
        max_a=abs_a;
        ind_max=j;
      }
    }
    if (max_a<=tolerance) {
      cnt_pivots=0-1;
      break;
    }
    cnt_pivots++ ;
    for (k=0; k<=n-1; k++ ) 
      temp_row[k]=P[i*n+k];
    for (k=0; k<=n-1; k++ ) 
      P[i*n+k]=P[ind_max*n+k];
    for (k=0; k<=n-1; k++ ) 
      P[ind_max*n+k]=temp_row[k];
    for (k=0; k<=n-1; k++ ) 
      temp_row[k]=U[i*n+k];
    for (k=0; k<=n-1; k++ ) 
      U[i*n+k]=U[ind_max*n+k];
    for (k=0; k<=n-1; k++ ) 
      U[ind_max*n+k]=temp_row[k];
    for (j=i+1; j<=n-1; j++ ) {
      coeff=(U[j*n+i]/U[i*n+i]);
      L[j*n+i]=coeff;
      for (k=i; k<=n-1; k++ ) {
        U[j*n+k]=U[j*n+k]-coeff*U[i*n+k];
      }
    }
  }
  /*//end main for*/
/*@ end @*/
/*@ end @*/

  return cnt_pivots;


}

// currently not tuned because of function calls


double determinant_matrix(double* mat_a, int n) {


  /* begin PerfTuning (

    def build {
      arg build_command = 'gcc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 5;
    }

    def performance_params {  
      param U_I[] = range(1,31);

      param VEC[] = [False,True];

      param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];

    }

    def input_params {
      let N = [100];
      param n[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[n*n] = random;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) */


  double det = 1.0;

  int i, num_pivots;
  int size_a = n * n;

  double L[size_a];
  double U[size_a];
  double P[size_a];
  
  num_pivots = compute_LUP(mat_a, L, U, P, n);

  if(num_pivots == -1) return 0;
  
  det = (num_pivots%2) == 1 ? -1.0 : 1.0;


  /* begin Loop (  
    transform Composite(
      unrolljam = (['i'],[U_I]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= n-1; i++) {
      det *= U[i*n+i];
    }
  ) */

  for (i = 0; i <= n-1; i++) {
    det *= U[i*n+i];
  }
  

/* end @*/
/* end @*/

  return det;
}



void multiply_matrix(TYPE* mat_a, int rows_a, int cols_a, 
                     TYPE* mat_b, int cols_b, 
                     TYPE* mat_c) {


  /*@ begin PerfTuning (

    def build {
      arg build_command = 'gcc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 5;
    }

    def performance_params {  
      param U_I[] = range(1,31);
      param U_J[] = range(1,31);
      param U_K[] = range(1,31);

      param VEC[] = [False,True];

      param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];
      constraint unroll_limit = ((U_I == 1) or (U_J == 1) or (U_K == 1));

    }

    def input_params {
      let N = [6, 10, 15, 20];
      param rows_a[] = N;
      param cols_a[] = N;
      param cols_b[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[rows_a*cols_a] = random;
      decl dynamic double mat_b[cols_b*cols_b] = random;
      decl dynamic double mat_c[rows_a*cols_b] = 0;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) @*/

  int i, j, k;
  int c_ind, a_row, c_row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j','k'],[U_I,U_J,U_K]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows_a-1; i++) {
      a_row = cols_a * i;
      c_row = cols_b * i;
      for (j = 0; j <= cols_b-1; j++) {
        c_ind = j + c_row;
        mat_c[c_ind] = 0;
        for (k = 0; k <= cols_a-1; k++) {
          mat_c[c_ind] += mat_a[a_row + k] * mat_b[cols_b * k + j];
        }
      } 
    }
  ) @*/

  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    c_row = cols_b * i;
    for (j = 0; j <= cols_b-1; j++) {
      c_ind = j + c_row;
      mat_c[c_ind] = 0;
      for (k = 0; k <= cols_a-1; k++) {
        mat_c[c_ind] += mat_a[a_row + k] * mat_b[cols_b * k + j];
      }
    } 
  }

/*@ end @*/
/*@ end @*/
}



void multiply_matrix_by_scalar(TYPE* mat_a, int rows, int cols, TYPE scalar, TYPE* mat_c) {

  /*@ begin PerfTuning (

    def build {
      arg build_command = 'gcc';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 5;
    }

    def performance_params {  
      param U_I[] = range(1,31);
      param U_J[] = range(1,31);

      param VEC[] = [False,True];

      param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];
      constraint unroll_limit = ((U_I == 1) or (U_J == 1));

    }

    def input_params {
      let N = [6, 10, 15, 20];
      param rows[] = N;
      param cols[] = N;
    }

    def input_vars {
      decl dynamic double mat_a[rows*cols] = random;
      decl dynamic double mat_b[rows*cols] = random;
      decl dynamic double mat_c[rows*cols] = 0;
      decl double scalar = random;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) @*/
  if ((rows<=6) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.086e-06, 3.8e-07, 3.24e-07, 3.18e-07, 3.21e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 6 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-6; i=i+6) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=6) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.055e-06, 4.78e-07, 4.13e-07, 3.99e-07, 4.09e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 6 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-6; i=i+6) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=6) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.35e-06, 5.89e-07, 5.12e-07, 5.15e-07, 5.19e-07] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 6 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-6; i=i+6) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=6) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.556e-06, 7.08e-07, 6.41e-07, 6.23e-07, 6.21e-07] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 6 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 6 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-6; i=i+6) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%6); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=10) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.654e-06, 4.98e-07, 4.07e-07, 4.04e-07, 4.06e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=10) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.506e-06, 6.33e-07, 5.46e-07, 5.45e-07, 5.4e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=10) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.607e-06, 8.27e-07, 7.21e-07, 7.13e-07, 7.13e-07] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=10) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.894e-06, 1.056e-06, 9.52e-07, 9.5e-07, 9.46e-07] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 10 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 5 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-5; i=i+5) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%5); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=15) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.49e-06, 6.28e-07, 5.1e-07, 5.08e-07, 5.06e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 15 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-15; i=i+15) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=15) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.667e-06, 8.44e-07, 7.31e-07, 7.2e-07, 7.24e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 15 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-15; i=i+15) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=15) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.274e-06, 1.091e-06, 9.78e-07, 9.75e-07, 9.74e-07] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 15 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-15; i=i+15) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=15) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.397e-06, 1.382e-06, 1.261e-06, 1.257e-06, 1.255e-06] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 15 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 15 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-15; i=i+15) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%15); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=20) && (cols<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.565e-06, 7.19e-07, 6.31e-07, 6.31e-07, 6.36e-07] 
Tuned for specific problem sizes: 
  cols = 6 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-10; i=i+10) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%10); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=20) && (cols<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.106e-06, 1.025e-06, 9e-07, 8.98e-07, 9.02e-07] 
Tuned for specific problem sizes: 
  cols = 10 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 20 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-20; i=i+20) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      row=cols*(i+15);
      row=cols*(i+16);
      row=cols*(i+17);
      row=cols*(i+18);
      row=cols*(i+19);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%20); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=20) && (cols<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.583e-06, 1.375e-06, 1.26e-06, 1.252e-06, 1.254e-06] 
Tuned for specific problem sizes: 
  cols = 15 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 20 
  U_J = 1 
  VEC = False 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-20; i=i+20) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      row=cols*(i+15);
      row=cols*(i+16);
      row=cols*(i+17);
      row=cols*(i+18);
      row=cols*(i+19);
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%20); i<=rows-1; i=i+1) {
      row=cols*i;
      for (j=0; j<=cols-1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
} else if ((rows<=20) && (cols<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.575e-06, 1.707e-06, 1.61e-06, 1.597e-06, 1.603e-06] 
Tuned for specific problem sizes: 
  cols = 20 
  rows = 20 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 20 
  U_J = 1 
  VEC = True 
--**/


    
  int i, j;
  int ind, row;


  /*@ begin Loop (  
    transform Composite(
      unrolljam = (['i','j'],[U_I,U_J]),
      vector = (VEC, ['ivdep','vector always'])
    )
    for (i = 0; i <= rows-1; i++) {
      row = cols * i;
      for (j = 0; j <= cols-1; j++) {
        ind = row + j;
        mat_c[ind] = mat_a[ind] * scalar;
      }
    }
  ) @*/
  {
    int i;
    for (i=0; i<=rows-20; i=i+20) {
      row=cols*i;
      row=cols*(i+1);
      row=cols*(i+2);
      row=cols*(i+3);
      row=cols*(i+4);
      row=cols*(i+5);
      row=cols*(i+6);
      row=cols*(i+7);
      row=cols*(i+8);
      row=cols*(i+9);
      row=cols*(i+10);
      row=cols*(i+11);
      row=cols*(i+12);
      row=cols*(i+13);
      row=cols*(i+14);
      row=cols*(i+15);
      row=cols*(i+16);
      row=cols*(i+17);
      row=cols*(i+18);
      row=cols*(i+19);
      register int cbv_1;
      cbv_1=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
    for (i=rows-((rows-(0))%20); i<=rows-1; i=i+1) {
      row=cols*i;
      register int cbv_2;
      cbv_2=cols-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        ind=row+j;
        mat_c[ind]=mat_a[ind]*scalar;
      }
    }
  }
/*@ end @*/
}
/*@ end @*/

  
}



void transpose_matrix(TYPE* mat_a, int rows_a, int cols_a, TYPE* mat_c) {
 

/*@ begin PerfTuning (

 def build {
   arg build_command = 'gcc';
   #arg libs = '-lrt';  # Only needed on linux
 } 

 def performance_counter {
   arg repetitions = 5;
 }

 def performance_params {  
  param U_I[] = range(1,31);
  param U_J[] = range(1,31);

  param VEC[] = [False,True];

  param CFLAGS[] = ['-O0', '-O1', '-O2', '-O3'];
  constraint unroll_limit = ((U_I == 1) or (U_J == 1));

 }
 
 def input_params {
  let N = [6, 10, 15, 20];
  param rows_a[] = N;
  param cols_a[] = N;
 }
 
 def input_vars {
   decl dynamic double mat_a[rows_a*cols_a] = random;
   decl dynamic double mat_c[rows_a*cols_a] = 0;
 }
 
 def search {
   arg algorithm = 'Exhaustive';
 }

) @*/
if ((rows_a<=6) && (cols_a<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.233e-06, 3.89e-07, 2.95e-07, 2.87e-07, 2.89e-07] 
Tuned for specific problem sizes: 
  cols_a = 6 
  rows_a = 6 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 6 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-6; i=i+6) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%6); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=6) && (cols_a<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.443e-06, 4.99e-07, 3.86e-07, 3.8e-07, 3.81e-07] 
Tuned for specific problem sizes: 
  cols_a = 10 
  rows_a = 6 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 1 
  U_J = 5 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
for (i=0; i<=rows_a-1; i++ ) {
  a_row=cols_a*i;
  {
    int j;
    for (j=0; j<=cols_a-5; j=j+5) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*(j+1)+i]=mat_a[a_row+j+1];
      mat_c[rows_a*(j+2)+i]=mat_a[a_row+j+2];
      mat_c[rows_a*(j+3)+i]=mat_a[a_row+j+3];
      mat_c[rows_a*(j+4)+i]=mat_a[a_row+j+4];
    }
    for (j=cols_a-((cols_a-(0))%5); j<=cols_a-1; j=j+1) 
      mat_c[rows_a*j+i]=mat_a[a_row+j];
  }
}
/*@ end @*/
} else if ((rows_a<=6) && (cols_a<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.462e-06, 5.71e-07, 4.66e-07, 4.67e-07, 4.65e-07] 
Tuned for specific problem sizes: 
  cols_a = 15 
  rows_a = 6 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 6 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-6; i=i+6) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%6); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=6) && (cols_a<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.332e-06, 6.63e-07, 5.53e-07, 5.38e-07, 5.35e-07] 
Tuned for specific problem sizes: 
  cols_a = 20 
  rows_a = 6 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 6 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-6; i=i+6) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%6); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=10) && (cols_a<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.301e-06, 4.57e-07, 3.65e-07, 3.67e-07, 3.66e-07] 
Tuned for specific problem sizes: 
  cols_a = 6 
  rows_a = 10 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 5 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-5; i=i+5) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%5); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=10) && (cols_a<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.406e-06, 5.94e-07, 4.94e-07, 4.67e-07, 4.69e-07] 
Tuned for specific problem sizes: 
  cols_a = 10 
  rows_a = 10 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-10; i=i+10) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%10); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=10) && (cols_a<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.486e-06, 7.27e-07, 6.24e-07, 6.12e-07, 6.12e-07] 
Tuned for specific problem sizes: 
  cols_a = 15 
  rows_a = 10 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 10 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-10; i=i+10) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%10); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=10) && (cols_a<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.934e-06, 8.59e-07, 7.73e-07, 7.61e-07, 7.6e-07] 
Tuned for specific problem sizes: 
  cols_a = 20 
  rows_a = 10 
Best performance parameters: 
  CFLAGS = -O1 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-10; i=i+10) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%10); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=15) && (cols_a<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.471e-06, 5.53e-07, 4.72e-07, 4.56e-07, 4.53e-07] 
Tuned for specific problem sizes: 
  cols_a = 6 
  rows_a = 15 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 7 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-7; i=i+7) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%7); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=15) && (cols_a<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.558e-06, 7.25e-07, 6.47e-07, 6.24e-07, 6.24e-07] 
Tuned for specific problem sizes: 
  cols_a = 10 
  rows_a = 15 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 15 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-15; i=i+15) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%15); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=15) && (cols_a<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.891e-06, 9.31e-07, 8.33e-07, 8.17e-07, 8.29e-07] 
Tuned for specific problem sizes: 
  cols_a = 15 
  rows_a = 15 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 15 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-15; i=i+15) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%15); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=15) && (cols_a<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.378e-06, 1.18e-06, 1.059e-06, 1.056e-06, 1.058e-06] 
Tuned for specific problem sizes: 
  cols_a = 20 
  rows_a = 15 
Best performance parameters: 
  CFLAGS = -O3 
  U_I = 15 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-15; i=i+15) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%15); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=20) && (cols_a<=6)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.609e-06, 6.54e-07, 5.45e-07, 5.4e-07, 5.39e-07] 
Tuned for specific problem sizes: 
  cols_a = 6 
  rows_a = 20 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 20 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-20; i=i+20) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    a_row=cols_a*(i+15);
    a_row=cols_a*(i+16);
    a_row=cols_a*(i+17);
    a_row=cols_a*(i+18);
    a_row=cols_a*(i+19);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
      mat_c[rows_a*j+i+15]=mat_a[a_row+j];
      mat_c[rows_a*j+i+16]=mat_a[a_row+j];
      mat_c[rows_a*j+i+17]=mat_a[a_row+j];
      mat_c[rows_a*j+i+18]=mat_a[a_row+j];
      mat_c[rows_a*j+i+19]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%20); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=20) && (cols_a<=10)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.679e-06, 9.01e-07, 7.85e-07, 7.68e-07, 7.72e-07] 
Tuned for specific problem sizes: 
  cols_a = 10 
  rows_a = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 10 
  U_J = 1 
  VEC = False 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-10; i=i+10) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%10); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    for (j=0; j<=cols_a-1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=20) && (cols_a<=15)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.268e-06, 1.238e-06, 1.099e-06, 1.101e-06, 1.091e-06] 
Tuned for specific problem sizes: 
  cols_a = 15 
  rows_a = 20 
Best performance parameters: 
  CFLAGS = -O0 
  U_I = 20 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-20; i=i+20) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    a_row=cols_a*(i+15);
    a_row=cols_a*(i+16);
    a_row=cols_a*(i+17);
    a_row=cols_a*(i+18);
    a_row=cols_a*(i+19);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
      mat_c[rows_a*j+i+15]=mat_a[a_row+j];
      mat_c[rows_a*j+i+16]=mat_a[a_row+j];
      mat_c[rows_a*j+i+17]=mat_a[a_row+j];
      mat_c[rows_a*j+i+18]=mat_a[a_row+j];
      mat_c[rows_a*j+i+19]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%20); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
} else if ((rows_a<=20) && (cols_a<=20)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.507e-06, 1.514e-06, 1.37e-06, 1.36e-06, 1.361e-06] 
Tuned for specific problem sizes: 
  cols_a = 20 
  rows_a = 20 
Best performance parameters: 
  CFLAGS = -O2 
  U_I = 20 
  U_J = 1 
  VEC = True 
--**/


  int i, j;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    a_row = cols_a * i;
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[a_row + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-20; i=i+20) {
    a_row=cols_a*i;
    a_row=cols_a*(i+1);
    a_row=cols_a*(i+2);
    a_row=cols_a*(i+3);
    a_row=cols_a*(i+4);
    a_row=cols_a*(i+5);
    a_row=cols_a*(i+6);
    a_row=cols_a*(i+7);
    a_row=cols_a*(i+8);
    a_row=cols_a*(i+9);
    a_row=cols_a*(i+10);
    a_row=cols_a*(i+11);
    a_row=cols_a*(i+12);
    a_row=cols_a*(i+13);
    a_row=cols_a*(i+14);
    a_row=cols_a*(i+15);
    a_row=cols_a*(i+16);
    a_row=cols_a*(i+17);
    a_row=cols_a*(i+18);
    a_row=cols_a*(i+19);
    register int cbv_1;
    cbv_1=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
      mat_c[rows_a*j+i+1]=mat_a[a_row+j];
      mat_c[rows_a*j+i+2]=mat_a[a_row+j];
      mat_c[rows_a*j+i+3]=mat_a[a_row+j];
      mat_c[rows_a*j+i+4]=mat_a[a_row+j];
      mat_c[rows_a*j+i+5]=mat_a[a_row+j];
      mat_c[rows_a*j+i+6]=mat_a[a_row+j];
      mat_c[rows_a*j+i+7]=mat_a[a_row+j];
      mat_c[rows_a*j+i+8]=mat_a[a_row+j];
      mat_c[rows_a*j+i+9]=mat_a[a_row+j];
      mat_c[rows_a*j+i+10]=mat_a[a_row+j];
      mat_c[rows_a*j+i+11]=mat_a[a_row+j];
      mat_c[rows_a*j+i+12]=mat_a[a_row+j];
      mat_c[rows_a*j+i+13]=mat_a[a_row+j];
      mat_c[rows_a*j+i+14]=mat_a[a_row+j];
      mat_c[rows_a*j+i+15]=mat_a[a_row+j];
      mat_c[rows_a*j+i+16]=mat_a[a_row+j];
      mat_c[rows_a*j+i+17]=mat_a[a_row+j];
      mat_c[rows_a*j+i+18]=mat_a[a_row+j];
      mat_c[rows_a*j+i+19]=mat_a[a_row+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%20); i<=rows_a-1; i=i+1) {
    a_row=cols_a*i;
    register int cbv_2;
    cbv_2=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_2; j++ ) {
      mat_c[rows_a*j+i]=mat_a[a_row+j];
    }
  }
}
/*@ end @*/
}
/*@ end @*/

}

