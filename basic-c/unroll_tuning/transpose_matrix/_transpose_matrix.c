#include "../../linear_algebra.h"


void transpose_matrix(KALMAN_TYPE* mat_a, int rows_a, int cols_a, KALMAN_TYPE* mat_c) {
 

/*@ begin PerfTuning (

 def build {
   arg build_command = 'icc';
   #arg libs = '-lrt';  # Only needed on linux
 } 

 def performance_counter {
   arg repetitions = 100;
 }

 def performance_params {  
  param U_I[] = range(1,7);
  param U_J[] = range(1,7);

  param VEC[] = [False,True];
 }
 
 def input_params {
      let N = [6];
  param rows_a[] = N;
  param cols_a[] = N;
 }
 
 def input_vars {
   decl dynamic double mat_a[rows_a*cols_a] = random;
   decl dynamic double mat_c[rows_a*cols_a] = 0;
 }
 
 def search {
   arg algorithm = 'Exhaustive';
 }

) @*/
/**-- (Generated by Orio) 
Best performance cost: 
  [1.956e-06, 5.74e-07, 5.05e-07, 5.03e-07, 5.08e-07, 5.05e-07, 5.1e-07, 5.04e-07, 5.03e-07, 5.08e-07, 5.04e-07, 5.07e-07, 5.05e-07, 5.03e-07, 5.08e-07, 5.08e-07, 4.98e-07, 5.06e-07, 5.06e-07, 5.07e-07, 5.08e-07, 5.06e-07, 5.08e-07, 5.05e-07, 5.11e-07, 5.05e-07, 5.01e-07, 5.07e-07, 5.03e-07, 5.02e-07, 5e-07, 5.09e-07, 5.1e-07, 5.05e-07, 5.05e-07, 5.09e-07, 5.01e-07, 5.06e-07, 5.02e-07, 5.03e-07, 5.04e-07, 5.1e-07, 5.04e-07, 5.04e-07, 5.02e-07, 5.05e-07, 5.1e-07, 5.1e-07, 5.09e-07, 5.1e-07, 5.11e-07, 5.09e-07, 5.01e-07, 5.02e-07, 5.06e-07, 5.03e-07, 5.03e-07, 5.07e-07, 5.08e-07, 5.07e-07, 4.98e-07, 5.03e-07, 5.08e-07, 5e-07, 5.01e-07, 5.05e-07, 5.07e-07, 5.05e-07, 5.02e-07, 5.09e-07, 5.1e-07, 5.05e-07, 5.04e-07, 5.05e-07, 5.04e-07, 5.05e-07, 5.03e-07, 5.07e-07, 5.04e-07, 5.09e-07, 5.1e-07, 5.03e-07, 5.02e-07, 5.05e-07, 5.06e-07, 5.03e-07, 5.04e-07, 5.02e-07, 5.03e-07, 5.12e-07, 5.03e-07, 5.08e-07, 5.06e-07, 5.05e-07, 5.09e-07, 4.99e-07, 5.09e-07, 5.05e-07, 5.04e-07, 5.11e-07] 
Tuned for specific problem sizes: 
  cols_a = 6 
  rows_a = 6 
Best performance parameters: 
  U_I = 5 
  U_J = 6 
  VEC = True 
--**/


  int i, j;
  int it,jt;
  int a_row;

/*@ begin Loop (  
  transform Composite(
    unrolljam = (['i','j'],[U_I,U_J]),
    vector = (VEC, ['ivdep','vector always'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= cols_a-1; j++) {
      mat_c[rows_a * j + i] = mat_a[cols_a * i + j];
    }
  }
) @*/
{
  int i;
  for (i=0; i<=rows_a-5; i=i+5) {
    int j;
    register int cbv_1;
    cbv_1=cols_a-6;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j=j+6) {
      mat_c[rows_a*j+i]=mat_a[cols_a*i+j];
      mat_c[rows_a*(j+1)+i]=mat_a[cols_a*i+j+1];
      mat_c[rows_a*(j+2)+i]=mat_a[cols_a*i+j+2];
      mat_c[rows_a*(j+3)+i]=mat_a[cols_a*i+j+3];
      mat_c[rows_a*(j+4)+i]=mat_a[cols_a*i+j+4];
      mat_c[rows_a*(j+5)+i]=mat_a[cols_a*i+j+5];
      mat_c[rows_a*j+i+1]=mat_a[cols_a*(i+1)+j];
      mat_c[rows_a*(j+1)+i+1]=mat_a[cols_a*(i+1)+j+1];
      mat_c[rows_a*(j+2)+i+1]=mat_a[cols_a*(i+1)+j+2];
      mat_c[rows_a*(j+3)+i+1]=mat_a[cols_a*(i+1)+j+3];
      mat_c[rows_a*(j+4)+i+1]=mat_a[cols_a*(i+1)+j+4];
      mat_c[rows_a*(j+5)+i+1]=mat_a[cols_a*(i+1)+j+5];
      mat_c[rows_a*j+i+2]=mat_a[cols_a*(i+2)+j];
      mat_c[rows_a*(j+1)+i+2]=mat_a[cols_a*(i+2)+j+1];
      mat_c[rows_a*(j+2)+i+2]=mat_a[cols_a*(i+2)+j+2];
      mat_c[rows_a*(j+3)+i+2]=mat_a[cols_a*(i+2)+j+3];
      mat_c[rows_a*(j+4)+i+2]=mat_a[cols_a*(i+2)+j+4];
      mat_c[rows_a*(j+5)+i+2]=mat_a[cols_a*(i+2)+j+5];
      mat_c[rows_a*j+i+3]=mat_a[cols_a*(i+3)+j];
      mat_c[rows_a*(j+1)+i+3]=mat_a[cols_a*(i+3)+j+1];
      mat_c[rows_a*(j+2)+i+3]=mat_a[cols_a*(i+3)+j+2];
      mat_c[rows_a*(j+3)+i+3]=mat_a[cols_a*(i+3)+j+3];
      mat_c[rows_a*(j+4)+i+3]=mat_a[cols_a*(i+3)+j+4];
      mat_c[rows_a*(j+5)+i+3]=mat_a[cols_a*(i+3)+j+5];
      mat_c[rows_a*j+i+4]=mat_a[cols_a*(i+4)+j];
      mat_c[rows_a*(j+1)+i+4]=mat_a[cols_a*(i+4)+j+1];
      mat_c[rows_a*(j+2)+i+4]=mat_a[cols_a*(i+4)+j+2];
      mat_c[rows_a*(j+3)+i+4]=mat_a[cols_a*(i+4)+j+3];
      mat_c[rows_a*(j+4)+i+4]=mat_a[cols_a*(i+4)+j+4];
      mat_c[rows_a*(j+5)+i+4]=mat_a[cols_a*(i+4)+j+5];
    }
    register int cbv_2, cbv_3;
    cbv_2=cols_a-((cols_a-(0))%6);
    cbv_3=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=cbv_2; j<=cbv_3; j=j+1) {
      mat_c[rows_a*j+i]=mat_a[cols_a*i+j];
      mat_c[rows_a*j+i+1]=mat_a[cols_a*(i+1)+j];
      mat_c[rows_a*j+i+2]=mat_a[cols_a*(i+2)+j];
      mat_c[rows_a*j+i+3]=mat_a[cols_a*(i+3)+j];
      mat_c[rows_a*j+i+4]=mat_a[cols_a*(i+4)+j];
    }
  }
  for (i=rows_a-((rows_a-(0))%5); i<=rows_a-1; i=i+1) {
    int j;
    register int cbv_4;
    cbv_4=cols_a-6;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_4; j=j+6) {
      mat_c[rows_a*j+i]=mat_a[cols_a*i+j];
      mat_c[rows_a*(j+1)+i]=mat_a[cols_a*i+j+1];
      mat_c[rows_a*(j+2)+i]=mat_a[cols_a*i+j+2];
      mat_c[rows_a*(j+3)+i]=mat_a[cols_a*i+j+3];
      mat_c[rows_a*(j+4)+i]=mat_a[cols_a*i+j+4];
      mat_c[rows_a*(j+5)+i]=mat_a[cols_a*i+j+5];
    }
    register int cbv_5, cbv_6;
    cbv_5=cols_a-((cols_a-(0))%6);
    cbv_6=cols_a-1;
#pragma ivdep
#pragma vector always
    for (j=cbv_5; j<=cbv_6; j=j+1) 
      mat_c[rows_a*j+i]=mat_a[cols_a*i+j];
  }
}
/*@ end @*/
/*@ end @*/

}
