
#include "../../matrix_batch.h"

void _multiply_matrix_batch(KALMAN_TYPE*** A, int rows_a, int cols_a,
                            KALMAN_TYPE*** B, int rows_b, int cols_b,
                            KALMAN_TYPE*** C,
                            int num_mats) {

/*@ begin PerfTuning (

    def build {
      arg build_command = 'icc -O2';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 2;
    }

    def performance_params {  
      param U_L[] = range(1,129);

      param VEC[] = [False,True];

      param RT1_L[] = [1,32];

      param T1_L[] = [1, 512, 1024];

      constraint tile2 = ((T1_L == 1) or (RT1_L == 1));
    }

    def input_params {
      let N = [8, 64, 128, 256];
      let M = [64, 256, 1000, 5000];
      param rows_a[] = N;
      param num_mats[] = M;
    }

    def input_vars {
      decl dynamic double A[rows_a][rows_a][num_mats] = random;
      decl dynamic double B[rows_a][rows_a][num_mats] = random;
      decl dynamic double C[rows_a][rows_a][num_mats] = 0;
    }

    def search {
      arg algorithm = 'MSimplex';
      arg total_runs  = 250;
    }

  ) @*/
if ((rows_a<=8) && (num_mats<=64)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [4.1196e-05, 3.9797e-05] 
Tuned for specific problem sizes: 
  num_mats = 64 
  rows_a = 8 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=8) && (num_mats<=256)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.00017716, 0.000175416] 
Tuned for specific problem sizes: 
  num_mats = 256 
  rows_a = 8 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=8) && (num_mats<=1000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.000737102, 0.000718302] 
Tuned for specific problem sizes: 
  num_mats = 1000 
  rows_a = 8 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=8) && (num_mats<=5000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.00212337, 0.00185571] 
Tuned for specific problem sizes: 
  num_mats = 5000 
  rows_a = 8 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=64) && (num_mats<=64)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.0172807, 0.0149756] 
Tuned for specific problem sizes: 
  num_mats = 64 
  rows_a = 64 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 512 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (ll=0; ll<=num_mats-1; ll=ll+512) {
        register int cbv_1;
        cbv_1=min(num_mats-1,ll+511);
#pragma ivdep
        for (l=ll; l<=cbv_1; l=l+1) {
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
        }
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=64) && (num_mats<=256)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.0338199, 0.0326355] 
Tuned for specific problem sizes: 
  num_mats = 256 
  rows_a = 64 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1024 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (ll=0; ll<=num_mats-1; ll=ll+1024) {
        register int cbv_1;
        cbv_1=min(num_mats-1,ll+1023);
#pragma ivdep
        for (l=ll; l<=cbv_1; l=l+1) {
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
        }
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=64) && (num_mats<=1000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.202716, 0.201064] 
Tuned for specific problem sizes: 
  num_mats = 1000 
  rows_a = 64 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=64) && (num_mats<=5000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.2988, 1.30363] 
Tuned for specific problem sizes: 
  num_mats = 5000 
  rows_a = 64 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=128) && (num_mats<=64)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.0935055, 0.0919528] 
Tuned for specific problem sizes: 
  num_mats = 64 
  rows_a = 128 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 512 
  U_L = 77 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (ll=0; ll<=num_mats-1; ll=ll+512) {
        int l;
        register int cbv_1;
        cbv_1=min(num_mats-1,ll+511)-76;
#pragma ivdep
        for (l=ll; l<=cbv_1; l=l+77) {
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
          C[i][j][(l+1)]=C[i][j][(l+1)]+A[i][k][(l+1)]*B[k][j][(l+1)];
          C[i][j][(l+2)]=C[i][j][(l+2)]+A[i][k][(l+2)]*B[k][j][(l+2)];
          C[i][j][(l+3)]=C[i][j][(l+3)]+A[i][k][(l+3)]*B[k][j][(l+3)];
          C[i][j][(l+4)]=C[i][j][(l+4)]+A[i][k][(l+4)]*B[k][j][(l+4)];
          C[i][j][(l+5)]=C[i][j][(l+5)]+A[i][k][(l+5)]*B[k][j][(l+5)];
          C[i][j][(l+6)]=C[i][j][(l+6)]+A[i][k][(l+6)]*B[k][j][(l+6)];
          C[i][j][(l+7)]=C[i][j][(l+7)]+A[i][k][(l+7)]*B[k][j][(l+7)];
          C[i][j][(l+8)]=C[i][j][(l+8)]+A[i][k][(l+8)]*B[k][j][(l+8)];
          C[i][j][(l+9)]=C[i][j][(l+9)]+A[i][k][(l+9)]*B[k][j][(l+9)];
          C[i][j][(l+10)]=C[i][j][(l+10)]+A[i][k][(l+10)]*B[k][j][(l+10)];
          C[i][j][(l+11)]=C[i][j][(l+11)]+A[i][k][(l+11)]*B[k][j][(l+11)];
          C[i][j][(l+12)]=C[i][j][(l+12)]+A[i][k][(l+12)]*B[k][j][(l+12)];
          C[i][j][(l+13)]=C[i][j][(l+13)]+A[i][k][(l+13)]*B[k][j][(l+13)];
          C[i][j][(l+14)]=C[i][j][(l+14)]+A[i][k][(l+14)]*B[k][j][(l+14)];
          C[i][j][(l+15)]=C[i][j][(l+15)]+A[i][k][(l+15)]*B[k][j][(l+15)];
          C[i][j][(l+16)]=C[i][j][(l+16)]+A[i][k][(l+16)]*B[k][j][(l+16)];
          C[i][j][(l+17)]=C[i][j][(l+17)]+A[i][k][(l+17)]*B[k][j][(l+17)];
          C[i][j][(l+18)]=C[i][j][(l+18)]+A[i][k][(l+18)]*B[k][j][(l+18)];
          C[i][j][(l+19)]=C[i][j][(l+19)]+A[i][k][(l+19)]*B[k][j][(l+19)];
          C[i][j][(l+20)]=C[i][j][(l+20)]+A[i][k][(l+20)]*B[k][j][(l+20)];
          C[i][j][(l+21)]=C[i][j][(l+21)]+A[i][k][(l+21)]*B[k][j][(l+21)];
          C[i][j][(l+22)]=C[i][j][(l+22)]+A[i][k][(l+22)]*B[k][j][(l+22)];
          C[i][j][(l+23)]=C[i][j][(l+23)]+A[i][k][(l+23)]*B[k][j][(l+23)];
          C[i][j][(l+24)]=C[i][j][(l+24)]+A[i][k][(l+24)]*B[k][j][(l+24)];
          C[i][j][(l+25)]=C[i][j][(l+25)]+A[i][k][(l+25)]*B[k][j][(l+25)];
          C[i][j][(l+26)]=C[i][j][(l+26)]+A[i][k][(l+26)]*B[k][j][(l+26)];
          C[i][j][(l+27)]=C[i][j][(l+27)]+A[i][k][(l+27)]*B[k][j][(l+27)];
          C[i][j][(l+28)]=C[i][j][(l+28)]+A[i][k][(l+28)]*B[k][j][(l+28)];
          C[i][j][(l+29)]=C[i][j][(l+29)]+A[i][k][(l+29)]*B[k][j][(l+29)];
          C[i][j][(l+30)]=C[i][j][(l+30)]+A[i][k][(l+30)]*B[k][j][(l+30)];
          C[i][j][(l+31)]=C[i][j][(l+31)]+A[i][k][(l+31)]*B[k][j][(l+31)];
          C[i][j][(l+32)]=C[i][j][(l+32)]+A[i][k][(l+32)]*B[k][j][(l+32)];
          C[i][j][(l+33)]=C[i][j][(l+33)]+A[i][k][(l+33)]*B[k][j][(l+33)];
          C[i][j][(l+34)]=C[i][j][(l+34)]+A[i][k][(l+34)]*B[k][j][(l+34)];
          C[i][j][(l+35)]=C[i][j][(l+35)]+A[i][k][(l+35)]*B[k][j][(l+35)];
          C[i][j][(l+36)]=C[i][j][(l+36)]+A[i][k][(l+36)]*B[k][j][(l+36)];
          C[i][j][(l+37)]=C[i][j][(l+37)]+A[i][k][(l+37)]*B[k][j][(l+37)];
          C[i][j][(l+38)]=C[i][j][(l+38)]+A[i][k][(l+38)]*B[k][j][(l+38)];
          C[i][j][(l+39)]=C[i][j][(l+39)]+A[i][k][(l+39)]*B[k][j][(l+39)];
          C[i][j][(l+40)]=C[i][j][(l+40)]+A[i][k][(l+40)]*B[k][j][(l+40)];
          C[i][j][(l+41)]=C[i][j][(l+41)]+A[i][k][(l+41)]*B[k][j][(l+41)];
          C[i][j][(l+42)]=C[i][j][(l+42)]+A[i][k][(l+42)]*B[k][j][(l+42)];
          C[i][j][(l+43)]=C[i][j][(l+43)]+A[i][k][(l+43)]*B[k][j][(l+43)];
          C[i][j][(l+44)]=C[i][j][(l+44)]+A[i][k][(l+44)]*B[k][j][(l+44)];
          C[i][j][(l+45)]=C[i][j][(l+45)]+A[i][k][(l+45)]*B[k][j][(l+45)];
          C[i][j][(l+46)]=C[i][j][(l+46)]+A[i][k][(l+46)]*B[k][j][(l+46)];
          C[i][j][(l+47)]=C[i][j][(l+47)]+A[i][k][(l+47)]*B[k][j][(l+47)];
          C[i][j][(l+48)]=C[i][j][(l+48)]+A[i][k][(l+48)]*B[k][j][(l+48)];
          C[i][j][(l+49)]=C[i][j][(l+49)]+A[i][k][(l+49)]*B[k][j][(l+49)];
          C[i][j][(l+50)]=C[i][j][(l+50)]+A[i][k][(l+50)]*B[k][j][(l+50)];
          C[i][j][(l+51)]=C[i][j][(l+51)]+A[i][k][(l+51)]*B[k][j][(l+51)];
          C[i][j][(l+52)]=C[i][j][(l+52)]+A[i][k][(l+52)]*B[k][j][(l+52)];
          C[i][j][(l+53)]=C[i][j][(l+53)]+A[i][k][(l+53)]*B[k][j][(l+53)];
          C[i][j][(l+54)]=C[i][j][(l+54)]+A[i][k][(l+54)]*B[k][j][(l+54)];
          C[i][j][(l+55)]=C[i][j][(l+55)]+A[i][k][(l+55)]*B[k][j][(l+55)];
          C[i][j][(l+56)]=C[i][j][(l+56)]+A[i][k][(l+56)]*B[k][j][(l+56)];
          C[i][j][(l+57)]=C[i][j][(l+57)]+A[i][k][(l+57)]*B[k][j][(l+57)];
          C[i][j][(l+58)]=C[i][j][(l+58)]+A[i][k][(l+58)]*B[k][j][(l+58)];
          C[i][j][(l+59)]=C[i][j][(l+59)]+A[i][k][(l+59)]*B[k][j][(l+59)];
          C[i][j][(l+60)]=C[i][j][(l+60)]+A[i][k][(l+60)]*B[k][j][(l+60)];
          C[i][j][(l+61)]=C[i][j][(l+61)]+A[i][k][(l+61)]*B[k][j][(l+61)];
          C[i][j][(l+62)]=C[i][j][(l+62)]+A[i][k][(l+62)]*B[k][j][(l+62)];
          C[i][j][(l+63)]=C[i][j][(l+63)]+A[i][k][(l+63)]*B[k][j][(l+63)];
          C[i][j][(l+64)]=C[i][j][(l+64)]+A[i][k][(l+64)]*B[k][j][(l+64)];
          C[i][j][(l+65)]=C[i][j][(l+65)]+A[i][k][(l+65)]*B[k][j][(l+65)];
          C[i][j][(l+66)]=C[i][j][(l+66)]+A[i][k][(l+66)]*B[k][j][(l+66)];
          C[i][j][(l+67)]=C[i][j][(l+67)]+A[i][k][(l+67)]*B[k][j][(l+67)];
          C[i][j][(l+68)]=C[i][j][(l+68)]+A[i][k][(l+68)]*B[k][j][(l+68)];
          C[i][j][(l+69)]=C[i][j][(l+69)]+A[i][k][(l+69)]*B[k][j][(l+69)];
          C[i][j][(l+70)]=C[i][j][(l+70)]+A[i][k][(l+70)]*B[k][j][(l+70)];
          C[i][j][(l+71)]=C[i][j][(l+71)]+A[i][k][(l+71)]*B[k][j][(l+71)];
          C[i][j][(l+72)]=C[i][j][(l+72)]+A[i][k][(l+72)]*B[k][j][(l+72)];
          C[i][j][(l+73)]=C[i][j][(l+73)]+A[i][k][(l+73)]*B[k][j][(l+73)];
          C[i][j][(l+74)]=C[i][j][(l+74)]+A[i][k][(l+74)]*B[k][j][(l+74)];
          C[i][j][(l+75)]=C[i][j][(l+75)]+A[i][k][(l+75)]*B[k][j][(l+75)];
          C[i][j][(l+76)]=C[i][j][(l+76)]+A[i][k][(l+76)]*B[k][j][(l+76)];
        }
        register int cbv_2, cbv_3;
        cbv_2=(min(num_mats-1,ll+511))-(((min(num_mats-1,ll+511))-(ll)+1)%77)+1;
        cbv_3=min(num_mats-1,ll+511);
#pragma ivdep
        for (l=cbv_2; l<=cbv_3; l=l+1) 
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=128) && (num_mats<=256)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [0.44176, 0.429055] 
Tuned for specific problem sizes: 
  num_mats = 256 
  rows_a = 128 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=128) && (num_mats<=1000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [2.1354, 2.13449] 
Tuned for specific problem sizes: 
  num_mats = 1000 
  rows_a = 128 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=128) && (num_mats<=5000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [11.1176, 11.1413] 
Tuned for specific problem sizes: 
  num_mats = 5000 
  rows_a = 128 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=256) && (num_mats<=64)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [1.50392, 1.4862] 
Tuned for specific problem sizes: 
  num_mats = 64 
  rows_a = 256 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1024 
  U_L = 89 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (ll=0; ll<=num_mats-1; ll=ll+1024) {
        int l;
        register int cbv_1;
        cbv_1=min(num_mats-1,ll+1023)-88;
#pragma ivdep
        for (l=ll; l<=cbv_1; l=l+89) {
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
          C[i][j][(l+1)]=C[i][j][(l+1)]+A[i][k][(l+1)]*B[k][j][(l+1)];
          C[i][j][(l+2)]=C[i][j][(l+2)]+A[i][k][(l+2)]*B[k][j][(l+2)];
          C[i][j][(l+3)]=C[i][j][(l+3)]+A[i][k][(l+3)]*B[k][j][(l+3)];
          C[i][j][(l+4)]=C[i][j][(l+4)]+A[i][k][(l+4)]*B[k][j][(l+4)];
          C[i][j][(l+5)]=C[i][j][(l+5)]+A[i][k][(l+5)]*B[k][j][(l+5)];
          C[i][j][(l+6)]=C[i][j][(l+6)]+A[i][k][(l+6)]*B[k][j][(l+6)];
          C[i][j][(l+7)]=C[i][j][(l+7)]+A[i][k][(l+7)]*B[k][j][(l+7)];
          C[i][j][(l+8)]=C[i][j][(l+8)]+A[i][k][(l+8)]*B[k][j][(l+8)];
          C[i][j][(l+9)]=C[i][j][(l+9)]+A[i][k][(l+9)]*B[k][j][(l+9)];
          C[i][j][(l+10)]=C[i][j][(l+10)]+A[i][k][(l+10)]*B[k][j][(l+10)];
          C[i][j][(l+11)]=C[i][j][(l+11)]+A[i][k][(l+11)]*B[k][j][(l+11)];
          C[i][j][(l+12)]=C[i][j][(l+12)]+A[i][k][(l+12)]*B[k][j][(l+12)];
          C[i][j][(l+13)]=C[i][j][(l+13)]+A[i][k][(l+13)]*B[k][j][(l+13)];
          C[i][j][(l+14)]=C[i][j][(l+14)]+A[i][k][(l+14)]*B[k][j][(l+14)];
          C[i][j][(l+15)]=C[i][j][(l+15)]+A[i][k][(l+15)]*B[k][j][(l+15)];
          C[i][j][(l+16)]=C[i][j][(l+16)]+A[i][k][(l+16)]*B[k][j][(l+16)];
          C[i][j][(l+17)]=C[i][j][(l+17)]+A[i][k][(l+17)]*B[k][j][(l+17)];
          C[i][j][(l+18)]=C[i][j][(l+18)]+A[i][k][(l+18)]*B[k][j][(l+18)];
          C[i][j][(l+19)]=C[i][j][(l+19)]+A[i][k][(l+19)]*B[k][j][(l+19)];
          C[i][j][(l+20)]=C[i][j][(l+20)]+A[i][k][(l+20)]*B[k][j][(l+20)];
          C[i][j][(l+21)]=C[i][j][(l+21)]+A[i][k][(l+21)]*B[k][j][(l+21)];
          C[i][j][(l+22)]=C[i][j][(l+22)]+A[i][k][(l+22)]*B[k][j][(l+22)];
          C[i][j][(l+23)]=C[i][j][(l+23)]+A[i][k][(l+23)]*B[k][j][(l+23)];
          C[i][j][(l+24)]=C[i][j][(l+24)]+A[i][k][(l+24)]*B[k][j][(l+24)];
          C[i][j][(l+25)]=C[i][j][(l+25)]+A[i][k][(l+25)]*B[k][j][(l+25)];
          C[i][j][(l+26)]=C[i][j][(l+26)]+A[i][k][(l+26)]*B[k][j][(l+26)];
          C[i][j][(l+27)]=C[i][j][(l+27)]+A[i][k][(l+27)]*B[k][j][(l+27)];
          C[i][j][(l+28)]=C[i][j][(l+28)]+A[i][k][(l+28)]*B[k][j][(l+28)];
          C[i][j][(l+29)]=C[i][j][(l+29)]+A[i][k][(l+29)]*B[k][j][(l+29)];
          C[i][j][(l+30)]=C[i][j][(l+30)]+A[i][k][(l+30)]*B[k][j][(l+30)];
          C[i][j][(l+31)]=C[i][j][(l+31)]+A[i][k][(l+31)]*B[k][j][(l+31)];
          C[i][j][(l+32)]=C[i][j][(l+32)]+A[i][k][(l+32)]*B[k][j][(l+32)];
          C[i][j][(l+33)]=C[i][j][(l+33)]+A[i][k][(l+33)]*B[k][j][(l+33)];
          C[i][j][(l+34)]=C[i][j][(l+34)]+A[i][k][(l+34)]*B[k][j][(l+34)];
          C[i][j][(l+35)]=C[i][j][(l+35)]+A[i][k][(l+35)]*B[k][j][(l+35)];
          C[i][j][(l+36)]=C[i][j][(l+36)]+A[i][k][(l+36)]*B[k][j][(l+36)];
          C[i][j][(l+37)]=C[i][j][(l+37)]+A[i][k][(l+37)]*B[k][j][(l+37)];
          C[i][j][(l+38)]=C[i][j][(l+38)]+A[i][k][(l+38)]*B[k][j][(l+38)];
          C[i][j][(l+39)]=C[i][j][(l+39)]+A[i][k][(l+39)]*B[k][j][(l+39)];
          C[i][j][(l+40)]=C[i][j][(l+40)]+A[i][k][(l+40)]*B[k][j][(l+40)];
          C[i][j][(l+41)]=C[i][j][(l+41)]+A[i][k][(l+41)]*B[k][j][(l+41)];
          C[i][j][(l+42)]=C[i][j][(l+42)]+A[i][k][(l+42)]*B[k][j][(l+42)];
          C[i][j][(l+43)]=C[i][j][(l+43)]+A[i][k][(l+43)]*B[k][j][(l+43)];
          C[i][j][(l+44)]=C[i][j][(l+44)]+A[i][k][(l+44)]*B[k][j][(l+44)];
          C[i][j][(l+45)]=C[i][j][(l+45)]+A[i][k][(l+45)]*B[k][j][(l+45)];
          C[i][j][(l+46)]=C[i][j][(l+46)]+A[i][k][(l+46)]*B[k][j][(l+46)];
          C[i][j][(l+47)]=C[i][j][(l+47)]+A[i][k][(l+47)]*B[k][j][(l+47)];
          C[i][j][(l+48)]=C[i][j][(l+48)]+A[i][k][(l+48)]*B[k][j][(l+48)];
          C[i][j][(l+49)]=C[i][j][(l+49)]+A[i][k][(l+49)]*B[k][j][(l+49)];
          C[i][j][(l+50)]=C[i][j][(l+50)]+A[i][k][(l+50)]*B[k][j][(l+50)];
          C[i][j][(l+51)]=C[i][j][(l+51)]+A[i][k][(l+51)]*B[k][j][(l+51)];
          C[i][j][(l+52)]=C[i][j][(l+52)]+A[i][k][(l+52)]*B[k][j][(l+52)];
          C[i][j][(l+53)]=C[i][j][(l+53)]+A[i][k][(l+53)]*B[k][j][(l+53)];
          C[i][j][(l+54)]=C[i][j][(l+54)]+A[i][k][(l+54)]*B[k][j][(l+54)];
          C[i][j][(l+55)]=C[i][j][(l+55)]+A[i][k][(l+55)]*B[k][j][(l+55)];
          C[i][j][(l+56)]=C[i][j][(l+56)]+A[i][k][(l+56)]*B[k][j][(l+56)];
          C[i][j][(l+57)]=C[i][j][(l+57)]+A[i][k][(l+57)]*B[k][j][(l+57)];
          C[i][j][(l+58)]=C[i][j][(l+58)]+A[i][k][(l+58)]*B[k][j][(l+58)];
          C[i][j][(l+59)]=C[i][j][(l+59)]+A[i][k][(l+59)]*B[k][j][(l+59)];
          C[i][j][(l+60)]=C[i][j][(l+60)]+A[i][k][(l+60)]*B[k][j][(l+60)];
          C[i][j][(l+61)]=C[i][j][(l+61)]+A[i][k][(l+61)]*B[k][j][(l+61)];
          C[i][j][(l+62)]=C[i][j][(l+62)]+A[i][k][(l+62)]*B[k][j][(l+62)];
          C[i][j][(l+63)]=C[i][j][(l+63)]+A[i][k][(l+63)]*B[k][j][(l+63)];
          C[i][j][(l+64)]=C[i][j][(l+64)]+A[i][k][(l+64)]*B[k][j][(l+64)];
          C[i][j][(l+65)]=C[i][j][(l+65)]+A[i][k][(l+65)]*B[k][j][(l+65)];
          C[i][j][(l+66)]=C[i][j][(l+66)]+A[i][k][(l+66)]*B[k][j][(l+66)];
          C[i][j][(l+67)]=C[i][j][(l+67)]+A[i][k][(l+67)]*B[k][j][(l+67)];
          C[i][j][(l+68)]=C[i][j][(l+68)]+A[i][k][(l+68)]*B[k][j][(l+68)];
          C[i][j][(l+69)]=C[i][j][(l+69)]+A[i][k][(l+69)]*B[k][j][(l+69)];
          C[i][j][(l+70)]=C[i][j][(l+70)]+A[i][k][(l+70)]*B[k][j][(l+70)];
          C[i][j][(l+71)]=C[i][j][(l+71)]+A[i][k][(l+71)]*B[k][j][(l+71)];
          C[i][j][(l+72)]=C[i][j][(l+72)]+A[i][k][(l+72)]*B[k][j][(l+72)];
          C[i][j][(l+73)]=C[i][j][(l+73)]+A[i][k][(l+73)]*B[k][j][(l+73)];
          C[i][j][(l+74)]=C[i][j][(l+74)]+A[i][k][(l+74)]*B[k][j][(l+74)];
          C[i][j][(l+75)]=C[i][j][(l+75)]+A[i][k][(l+75)]*B[k][j][(l+75)];
          C[i][j][(l+76)]=C[i][j][(l+76)]+A[i][k][(l+76)]*B[k][j][(l+76)];
          C[i][j][(l+77)]=C[i][j][(l+77)]+A[i][k][(l+77)]*B[k][j][(l+77)];
          C[i][j][(l+78)]=C[i][j][(l+78)]+A[i][k][(l+78)]*B[k][j][(l+78)];
          C[i][j][(l+79)]=C[i][j][(l+79)]+A[i][k][(l+79)]*B[k][j][(l+79)];
          C[i][j][(l+80)]=C[i][j][(l+80)]+A[i][k][(l+80)]*B[k][j][(l+80)];
          C[i][j][(l+81)]=C[i][j][(l+81)]+A[i][k][(l+81)]*B[k][j][(l+81)];
          C[i][j][(l+82)]=C[i][j][(l+82)]+A[i][k][(l+82)]*B[k][j][(l+82)];
          C[i][j][(l+83)]=C[i][j][(l+83)]+A[i][k][(l+83)]*B[k][j][(l+83)];
          C[i][j][(l+84)]=C[i][j][(l+84)]+A[i][k][(l+84)]*B[k][j][(l+84)];
          C[i][j][(l+85)]=C[i][j][(l+85)]+A[i][k][(l+85)]*B[k][j][(l+85)];
          C[i][j][(l+86)]=C[i][j][(l+86)]+A[i][k][(l+86)]*B[k][j][(l+86)];
          C[i][j][(l+87)]=C[i][j][(l+87)]+A[i][k][(l+87)]*B[k][j][(l+87)];
          C[i][j][(l+88)]=C[i][j][(l+88)]+A[i][k][(l+88)]*B[k][j][(l+88)];
        }
        register int cbv_2, cbv_3;
        cbv_2=(min(num_mats-1,ll+1023))-(((min(num_mats-1,ll+1023))-(ll)+1)%89)+1;
        cbv_3=min(num_mats-1,ll+1023);
#pragma ivdep
        for (l=cbv_2; l<=cbv_3; l=l+1) 
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=256) && (num_mats<=256)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [5.19913, 5.202] 
Tuned for specific problem sizes: 
  num_mats = 256 
  rows_a = 256 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      register int cbv_1;
      cbv_1=num_mats-1;
#pragma ivdep
      for (l=0; l<=cbv_1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=256) && (num_mats<=1000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [18.5742, 18.4095] 
Tuned for specific problem sizes: 
  num_mats = 1000 
  rows_a = 256 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 512 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (ll=0; ll<=num_mats-1; ll=ll+512) {
        register int cbv_1;
        cbv_1=min(num_mats-1,ll+511);
#pragma ivdep
        for (l=ll; l<=cbv_1; l=l+1) {
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
        }
      }
    }
  }
}
/*@ end @*/
} else if ((rows_a<=256) && (num_mats<=5000)) {

/**-- (Generated by Orio) 
Best performance cost: 
  [85.7985, 85.8771] 
Tuned for specific problem sizes: 
  num_mats = 5000 
  rows_a = 256 
Best performance parameters: 
  RT1_L = 1 
  T1_L = 1024 
  U_L = 1 
  VEC = True 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   regtile = (['l'],[RT1_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    unrolljam = (['l'],[U_L]),
    regtile = (['l'],[RT1_L]),
    tile = ([('l',T1_L,'ll')]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (ll=0; ll<=num_mats-1; ll=ll+1024) {
        register int cbv_1;
        cbv_1=min(num_mats-1,ll+1023);
#pragma ivdep
        for (l=ll; l<=cbv_1; l=l+1) {
          C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
        }
      }
    }
  }
}
/*@ end @*/
}
/*@ end @*/
} 
