
#include "../../matrix_batch.h"

void _multiply_matrix_batch(KALMAN_TYPE*** A, int rows_a, int cols_a,
                            KALMAN_TYPE*** B, int rows_b, int cols_b,
                            KALMAN_TYPE*** C,
                            int num_mats) {

/*@ begin PerfTuning (

    def build {
      arg build_command = 'icpc -O2';
      #arg libs = '-lrt';  # Only needed on linux
    } 

    def performance_counter {
      arg repetitions = 2;
    }

    def performance_params {  
      param U_L[] = range(1,10);

      param VEC[] = [False, True];

      param T1_L[] = [8,16];

    }


    def input_params {
      let N = [32];
      let M = [500];
      param rows_a[] = N;
      param num_mats[] = M;
    }

    def input_vars {
      decl dynamic double A[rows_a][rows_a][num_mats] = random;
      decl dynamic double B[rows_a][rows_a][num_mats] = random;
      decl dynamic double C[rows_a][rows_a][num_mats] = 0;
    }

    def search {
      arg algorithm = 'Exhaustive';
    }

  ) @*/
/**-- (Generated by Orio) 
Best performance cost: 
  [0.0137146, 0.012866] 
Tuned for specific problem sizes: 
  num_mats = 500 
  rows_a = 32 
Best performance parameters: 
  T1_L = 8 
  U_L = 1 
  VEC = False 
--**/


  int i,j,k,l;
  int it,jt,kt,lt, ll;
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y)) 


  // transform Composite(
  //   unrolljam = (['l'],[U_L]),
  //   tile = ([('l',T1_L,'ll')]),
  //   vector = (VEC, ['vector always'])
  // )
  // for (i = 0; i <= rows_a-1; i++) {
  //   for (j = 0; j <= rows_a-1; j++) {
  //     for (l = 0; l <= num_mats-1; l++) {
  //       C[i][j][l] = 0;
  //     }
  //   }
  // }

/*@ begin Loop (  
  

      
  transform Composite(
    regtile = (['l'],[T1_L]),
    vector = (VEC, ['ivdep'])
  )
  for (i = 0; i <= rows_a-1; i++) {
    for (j = 0; j <= rows_a-1; j++) {
      for (k = 0; k <= rows_a-1; k++) {
        for (l = 0; l <= num_mats-1; l++) {
          C[i][j][l] += A[i][k][l] * B[k][j][l];
        }
      }
    } 
  }

  ) @*/
for (i=0; i<=rows_a-1; i++ ) {
  for (j=0; j<=rows_a-1; j++ ) {
    for (k=0; k<=rows_a-1; k++ ) {
      for (lt=0; lt<=num_mats-8; lt=lt+8) {
        C[i][j][lt]=C[i][j][lt]+A[i][k][lt]*B[k][j][lt];
        C[i][j][(lt+1)]=C[i][j][(lt+1)]+A[i][k][(lt+1)]*B[k][j][(lt+1)];
        C[i][j][(lt+2)]=C[i][j][(lt+2)]+A[i][k][(lt+2)]*B[k][j][(lt+2)];
        C[i][j][(lt+3)]=C[i][j][(lt+3)]+A[i][k][(lt+3)]*B[k][j][(lt+3)];
        C[i][j][(lt+4)]=C[i][j][(lt+4)]+A[i][k][(lt+4)]*B[k][j][(lt+4)];
        C[i][j][(lt+5)]=C[i][j][(lt+5)]+A[i][k][(lt+5)]*B[k][j][(lt+5)];
        C[i][j][(lt+6)]=C[i][j][(lt+6)]+A[i][k][(lt+6)]*B[k][j][(lt+6)];
        C[i][j][(lt+7)]=C[i][j][(lt+7)]+A[i][k][(lt+7)]*B[k][j][(lt+7)];
      }
      for (l=lt; l<=num_mats-1; l=l+1) {
        C[i][j][l]=C[i][j][l]+A[i][k][l]*B[k][j][l];
      }
    }
  }
}
/*@ end @*/
/*@ end @*/
} 
